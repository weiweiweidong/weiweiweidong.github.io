[{"title":"AtCoder Beginner Contest 363 Summary","url":"/2024/blog/5677/","content":"本文是 AtCoder Beginner Conteset（ABC）363 的总结笔记。\n\n\nA - Piling UpProblem：A - Piling Up\n省略\n// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;void solve() {    int n;    cin &gt;&gt; n;    if (n &gt;= 200)        cout &lt;&lt; 300 - n &lt;&lt; endl;    else if (n &gt;= 100)        cout &lt;&lt; 200 - n &lt;&lt; endl;    else        cout &lt;&lt; 100 - n &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nB - Japanese Cursed DollProblem：B - Japanese Cursed Doll\n省略。\n// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 110;int cnt[N];int n, t, p;void solve() {    cin &gt;&gt; n &gt;&gt; t &gt;&gt; p;    for (int i = 0; i &lt; n; i++) {        int x;        cin &gt;&gt; x;        cnt[x]++;    }    for (int i = 1; i &lt; N; i++)        cnt[i] += cnt[i - 1];    // 遍历长度    for (int len = 100; len &gt;= 0; len--)        // 长度为 i 以上的人数达到了 p 人        if (cnt[100] - cnt[len - 1] &gt;= p) {            cout &lt;&lt; max(0, t - len) &lt;&lt; endl;            break;        }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - Avoid K Palindrome 2Problem：C - Avoid K Palindrome 2\n模拟题。\n题目：给定长度为  的小写字母字符串 。求  的排列数量，且其中不含长度为  的回文串子串。\n约束条件：\n思路：按照题目要求进行模拟即可。\n关键技术有两个：\n\n如何求  的全排列：使用 STL 的全排列函数 next_permutation 即可。并且 next_permutation 会自动去重。时间复杂度 。（注意，next_permutation 使用前要 sort，否则枚举会遗漏）\n如何快速验证回文串：双指针左右向中间夹逼即可。时间复杂度 \n\n整体时间复杂度最极端情况下是 ，在本题的规模下大约是 1e8，在约束时间范围内。\n// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, k;string s;// 快速判断回文bool check(int l, int r) {    while (l &lt; r)        if (s[l++] != s[r--])            return 0;    return 1;}void solve() {    cin &gt;&gt; n &gt;&gt; k;    cin &gt;&gt; s;    sort(s.begin(), s.end());    int res = 0;    int len = s.size();    do {        bool can = true;        for (int i = 0; i + k - 1 &lt; len; i++) {            if (check(i, i + k - 1)) {                can = false;                break;            }        }        if (can)            res++;    } while (next_permutation(s.begin(), s.end()));    // 备注：next_permutation 在用的时候会自动去重    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - Palindromic NumberProblem：D - Palindromic Number\n题目：形如  或者  的数称为回文数。求第  大的回文数。\n约束条件：\n思路：当对比数字大小的时候，有如下规律：\n\n位数长的一定比位数短的数字大\n相同长度下，高位数大的数字大\n\n对于一个回文串数，后半部分是前半部分的镜像，所以我们可以暂时忽略后半部分，仅仅使用上面两条规则，就可以比较出回文串数字的大小。\n通过观察，实际可以发现有如下的关系。此时回文串数字的大小也是递增的。\n\n\n根据上面规则，想要求出第  大的数：\n先通过迭代，确定这个数的位数范围，求出前面位数累计下来的回文串数  ；\n然后直接根据  确定在当前位数下的偏移量，再回文镜像生成需要的数字即可。\n这个数字会非常的大，但是能够看出来，回文串的前半部分肯定能被 long long 存下。\n// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_d// 找第n大的回文数#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;LL N;// 快速幂模板LL qpow(LL a, LL b) {    LL res = 1;    while (b) {        if (b &amp; 1)            res *= a;        a *= a;        b &gt;&gt;= 1;    }    return res;}void solve() {    cin &gt;&gt; N;    // 特判    if (N == 1) {        cout &lt;&lt; 0 &lt;&lt; endl;        return;    }    // 偏移量修正（把0给修正掉）    N--;    // 枚举回文串数字的位数    for (int d = 1;; d++) {        // 回文串数字对称轴左侧的位数        int x = (d + 1) / 2;        if (N &lt;= 9 * qpow(10, x - 1)) {            string S = to_string(qpow(10, x - 1) + N - 1);            // 把S长度扩展为d，后面不足的位置用' '补充            S.resize(d, ' ');            // 把后面的空位补上            for (int i = x; i &lt; d; i++)                S[i] = S[d - 1 - i];            cout &lt;&lt; S &lt;&lt; endl;            return;        } else {            N -= 9 * qpow(10, x - 1);        }    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Sinking LandProblem：E - Sinking Land\n优先队列 BFS\n题目：给定一个  的网格，每个格点有高度值 。网格外侧被海洋环绕，海平面以每单位 1 的速度上升。\n输出  时刻，没有被水淹没的格点的数量。\n约束条件：\n\n\n思路：经典的优先队列 BFS 模型。\n如下图所示。由于水肯定是从外边界往中心走。在初始化的时候，将所有外边界的点（粉色区域）都存入优先队列中。这里使用小根堆模型。\n取出最小值，可知当海平面高度为 2 的时候，会从这里开始灌水。此时将 2 周围的点存入优先队列，挨个弹出，直到优先队列最小值大于 2.\n再取出优先队列的最小值 3，说明海平面高度为 3 的时候，会开始灌水…….依次循环。\n\n\n所有的点都会进出一次优先队列，总时间复杂度为 。（备注： 是小根堆提供的时间复杂度）\n// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};struct Node {    int x, y, t;    bool operator&lt;(const Node&amp; a) const { return t &gt; a.t; }};priority_queue&lt;Node&gt; Q;const int N = 1010;int H, W, Y;int A[N][N];bool st[N][N];int res[100010];void solve() {    // 读入数据    cin &gt;&gt; H &gt;&gt; W &gt;&gt; Y;    for (int i = 1; i &lt;= H; i++)        for (int j = 1; j &lt;= W; j++)            cin &gt;&gt; A[i][j];    // 把边缘的格子加入小根堆    for (int i = 1; i &lt;= H; i++)        for (int j = 1; j &lt;= W; j++)            if (i == 1 || j == 1 || i == H || j == W) {                st[i][j] = true;                Q.push((Node){i, j, A[i][j]});            }    int T = 0;    while (Q.size()) {        // 拿出当前最低的格子        Node now = Q.top();        Q.pop();        int x = now.x, y = now.y, t = now.t;        T = max(T, t);        res[T]++;  // T 高度被淹的格子数量+1        // 看一下这个格子周围的四个方向        for (int i = 0; i &lt; 4; i++) {            int a = x + dx[i], b = y + dy[i];            // 越界            if (a &lt; 1 || a &gt; H || b &lt; 1 || b &gt; W)                continue;            // 已经在队列中            if (st[a][b])                continue;            // 入队            Q.push((Node){a, b, A[a][b]});            st[a][b] = true;        }    }    // 计算前缀和（已知i时刻淹了的格子数量，就知道0~i时刻总共被淹的格子数量）    for (int i = 1; i &lt;= Y; i++)        res[i] += res[i - 1];    // 输出结果    for (int i = 1; i &lt;= Y; i++)        cout &lt;&lt; H * W - res[i] &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nF - Palindromic ExpressionProblem：F - Palindromic Expression\nDFS\n题目：给定一个整数 ，输出一个满足下面条件的表达式 ：\n\n 长度在  以内，只包含数字  和 乘号 *\n 是回文串，且第一个字符是数字\n表达式  的计算结果等于 \n\n例如：363 可以拆成 11*3*11 或者直接输出 363\n约束条件：\n思路：使用 DFS 搜索。\n对于一个数字 n，我们可以先判断能否拆成  的形式，并且 x 和 y 轴对称。然后再将  作为输入，再向下继续 DFS，直到把它拆成一个形如 121 样子的回文串数字。最后拼接即可。\n// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_f// DFS#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;LL N;string dfs(LL n) {    string s = to_string(n);    string s_rev = s;    reverse(s_rev.begin(), s_rev.end());    int len = s.size();    bool zero_flag = false;    // 遍历看中间有没有 0 出现（因为我们想要的数中不能有0）    for (int i = 0; i &lt; len; i++)        if (s[i] == '0')            zero_flag = true;    // 如果没有 0 出现，并且是回文，直接返回    if (!zero_flag &amp;&amp; s == s_rev)        return s;    for (int i = 2, l = sqrt(n); i &lt;= l; i++) {        if (n % i == 0) {            bool flag = true;            int t = i, j = 0;            // 看看t里面是否有0（因为我们想要的数中不能有0）            while (t) {                if (t % 10 == 0)                    flag = false;                t /= 10;            }            t = i;            // 中间出现 0 了，直接跳过            if (!flag)                continue;            // 算出计算和 i 对称的数 j            while (t)                j = j * 10 + t % 10, t /= 10;            // 如果找到了这一对对称的数，就继续往下面搜            if ((n / i) % j == 0) {                string ret = dfs(n / i / j);                // 如果得到的结果不是空串                if (ret != \"\")                    return to_string(i) + \"*\" + ret + \"*\" + to_string(j);            }        }    }    return \"\";}void solve() {    cin &gt;&gt; N;    string ret = dfs(N);    if (ret != \"\")        cout &lt;&lt; ret &lt;&lt; endl;    else        cout &lt;&lt; -1 &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 376 Summary","url":"/2024/blog/33603/","content":"本文是 AtCoder Beginner Conteset（ABC）376 的总结笔记。\n\nA - Candy ButtonProblem：A - Candy Button\n很简单的模拟题。\n// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_a// 模拟题#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, c;int res;int last;int t;void solve() {    cin &gt;&gt; n &gt;&gt; c;    last = -c;  // 记录上次拿糖的时间，初始值设一个比较小的数即可    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; t;           // 读入当前时间        if (t - last &gt;= c)  // 间隔时间超过 c，就可以拿糖            res++, last = t;    }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nB - Hands on Ring (Easy)Problem：B - Hands on Ring (Easy)\n根据题目容易看出来，分成 6 种情况来讨论即可。\n// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_b// 模拟题目#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, Q;int L, R;char op[2];int t;int res;// a 起点，b 障碍，c 终点int move(int a, int b, int c) {    if (a &lt; b &amp;&amp; b &lt; c)        return a + n - c;    if (a &lt; c &amp;&amp; c &lt; b)        return c - a;    if (b &lt; c &amp;&amp; c &lt; a)        return a - c;    if (b &lt; a &amp;&amp; a &lt; c)        return c - a;    if (c &lt; a &amp;&amp; a &lt; b)        return a - c;    if (c &lt; b &amp;&amp; b &lt; a)        return c + n - a;    return 0;}void solve() {    cin &gt;&gt; n &gt;&gt; Q;    L = 1, R = 2;    while (Q--) {        cin &gt;&gt; op &gt;&gt; t;        if (*op == 'L')            res += move(L, R, t), L = t;        if (*op == 'R')            res += move(R, L, t), R = t;    }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - Prepare Another BoxProblem：C - Prepare Another Box\n贪心 + 二分\n题目：有编号为 1~N 的 N 个玩具，有编号为 1 ~ N-1 的 N-1 个盒子。\n再买一个大小为 x 的盒子。将 N 个玩具放入这 N 个盒子，并保证任何盒子都大于等于玩具。\n求最小的 x\n约束条件：\n\n思路：使用二分即可。\n时间复杂度 。\n// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_c// 贪心题目#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n;int A[N], B[N], c[N];// 检查 x 能否让 B 满足条件// true 表示满足条件，x 偏大，要向左边走// false 表示不满足条件，x 太小，要向右边走bool check(int x) {    for (int i = 1; i &lt; n; i++)        c[i] = B[i];    c[n] = x;    sort(c + 1, c + n + 1);    for (int i = 1; i &lt;= n; i++)        // 但凡出现了 false，说明插入的 x 太小了        if (A[i] &gt; c[i])            return false;    return true;}void solve() {    // 读入数据    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; A[i];  // 读入玩具的大小    for (int i = 1; i &lt;= n - 1; i++)        cin &gt;&gt; B[i];  // 读入盒子的大小    // 对 A 升序排序    sort(A + 1, A + n + 1);    int l = 1, r = A[n] + 1, ans = -1;    while (l &lt; r) {        int mid = (r + l) / 2;        if (check(mid))            r = mid, ans = mid;        else            l = mid + 1;    }    cout &lt;&lt; ans &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - CycleProblem：D - Cycle\n题目：N个节点 M 条边的有向简单图。\n判断是否有包含 1 节点的环。如果存在，求这个环的最小边数。\n约束条件：\n\n思路：本题使用两个方法来解。\n方法 1：BFS本题可以使用 BFS 的原因是：边权为 1。如果题目边权不为 1 的话，就没有办法使用 BFS 了\n// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int INF = 1e9 + 10;void solve() {    int n, m;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;vector&lt;int&gt;&gt; g(n + 10);  // 声明图。+10 是为了留余量    for (int i = 0; i &lt; m; i++) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        g[a].push_back(b);  // 添加边    }    queue&lt;int&gt; q;    vector&lt;int&gt; dis(n + 10, INF);    // 先把 1 周围的节点全部放入队列中    for (auto v : g[1]) {        q.push(v);        dis[v] = 1;    }    // BFS    while (!q.empty()) {        int now = q.front();        q.pop();        for (auto next : g[now]) {            if (dis[next] &lt; dis[now] + 1)                continue;            // 更新 next 点的距离            dis[next] = min(dis[next], dis[now] + 1);            // 如果遇到了 1，直接退出            if (next == 1)                break;            // 否则把 next 点加入队列            q.push(next);        }    }    cout &lt;&lt; (dis[1] == INF ? -1 : dis[1]) &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n方法 2：通用做法“1 节点能回到 1 节点” 意味着：( 1点能走到节点 K ) + ( 反向图 K 能走到 1 节点 )\n这时问题就转化为 求 1-&gt; k 的最短路 + k -&gt; 1 的最短路\n相当于两个图的最短路问题，使用两次堆优化版的 Dijkstra 即可。\n为了方便，本题使用了结构体，来方便的实现两个图的 dijkstra。\n// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n, m, ans;// 声明图的结构体struct Graph {    int h[N], e[N], ne[N], idx = 0;    int dist[N];    bool st[N];    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    // 图初始化    Graph() { memset(h, -1, sizeof h); }    // 加边    void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }    // dijkstra 求最短路    void dijkstra() {        memset(dist, 0x3f, sizeof dist);        dist[1] = 0;        heap.push({0, 1});        while (heap.size()) {            auto t = heap.top();            heap.pop();            int ver = t.second, d = t.first;            if (st[ver])                continue;            st[ver] = true;            for (int i = h[ver]; i != -1; i = ne[i]) {                int next = e[i];                if (dist[next] &gt; d + 1) {                    dist[next] = d + 1;                    heap.push({dist[next], next});                }            }        }    }} G1, G2;  // 声明了两个图void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; m;    // 建图    for (int i = 1; i &lt;= m; i++) {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        G1.add(a, b);  // 建正向图        G2.add(b, a);  // 建反向图    }    G1.dijkstra();    G2.dijkstra();    ans = n + 1;    for (int i = 2; i &lt;= n; i++)        ans = min(ans, G1.dist[i] + G2.dist[i]);    if (ans &gt; n)        cout &lt;&lt; -1 &lt;&lt; endl;    else        cout &lt;&lt; ans &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Max × SumProblem：E - Max × Sum\n贪心 + 大根堆\n题目：给定长度为  的序列  和 \n另  是  的长度为  的子集。求下面表达式的最小值：\n\n有  次询问。\n约束条件：\n\n\n思路：先把表达式拆成两个部分分析一下：\n对于一个大小为  的子集 ，前半部分表示子集  中  的最大值，后半部分表示子集内所有元素  的和。\n子问题 1：如何枚举所有的可能性？可以按照下图所示，从头遍历每个 。假设当前看到了第  号元素，那么从前面的  中选取  个元素，就能够保证不重不漏的枚举出所有可能的子集 \n\n\n子问题 2：如何维护  的最大值？提前将 A 数组升序排列，这样就能保证，如果当前看到的是编号  的数，无论前面的  如何选  个元素，都能保证  就是能枚举出来的子集的最大值。\n子问题 3：如何维护  的最小值？可以使用优先队列 priority_queue（大根堆）来维护。\n核心问题转化为如何在  中间选择最小的  个元素。那么只需要每次入栈一个数，再把最大的数字弹出。保证优先队列中只存在  个数即可。\n综上所述，算法总时间复杂度为 ，前半部分排序消耗 ，后半部分所有元素一进一出加上大根堆排序消耗  的时间复杂度。总时间复杂度在规定时间范围内。\n// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int MAXN = 2e5 + 10;int T, K, N;PII A[MAXN];priority_queue&lt;int&gt; Q;  // 大根堆LL ans, sum;void solve() {    cin &gt;&gt; T;    while (T--) {        cin &gt;&gt; N &gt;&gt; K;        for (int i = 1; i &lt;= N; i++)            cin &gt;&gt; A[i].first;        for (int i = 1; i &lt;= N; i++)            cin &gt;&gt; A[i].second;        // 排序        sort(A + 1, A + N + 1);        // 初始化        ans = 1e18, sum = 0;        // 清空堆 （注：priority_queue没有clear函数）        while (!Q.empty())            Q.pop();        // 处理前 K-1 个数        for (int i = 1; i &lt; K; i++) {            Q.push(A[i].second);            sum += (LL)A[i].second;        }        // 从第 K 个数开始        for (int i = K; i &lt;= N; i++) {            sum += (LL)A[i].second;            ans = min(ans, (LL)A[i].first * sum);            Q.push(A[i].second);            // 把看过的 B 的最大值弹出来去掉，就能保证 sum 的值是最小的            sum -= (LL)Q.top();            Q.pop();        }        cout &lt;&lt; ans &lt;&lt; endl;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 377 Summary","url":"/2024/blog/4942/","content":"本文是 AtCoder Beginner Conteset（ABC）377 的总结笔记。\n\nA - Rearranging ABCProblem：A - Rearranging ABC\n省略。\n// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;void solve() {    cin &gt;&gt; s;    sort(s.begin(), s.end());    if (s == \"ABC\")        cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else        cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nB - Avoid Rook AttackProblem：B - Avoid Rook Attack\n省略。\n// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 10;char g[N][N];int col[N], row[N];  // 记录该行该列是否被占用void solve() {    // 读入网格数据    for (int i = 0; i &lt; 8; i++)        cin &gt;&gt; g[i];    // 记录行列占用情况    for (int i = 0; i &lt; 8; i++)        for (int j = 0; j &lt; 8; j++)            if (g[i][j] == '#')                col[j] = row[i] = 1;    // 判断每个点是否安全    int res = 0;    for (int i = 0; i &lt; 8; i++)        for (int j = 0; j &lt; 8; j++)            if (!row[i] &amp;&amp; !col[j])                res++;    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - Avoid Knight AttackProblem：C - Avoid Knight Attack\nSTL\n题目：一个 N*N 的网格。骑士可以按照下面形式攻击周围的 8 个格子。\n\n\n输出网格上有多少安全点。\n约束条件：\n\n\n\n思路：题目的关键在于如何“去重”。\n方法 1：（稍微麻烦一些）使用 unordered_map&lt;int, unordered_set&lt;int&gt; &gt;，其中，第一维度用来存储 x 坐标，第二维度用于存储 y 坐标，unordered_set 就会自动对 y 的坐标进行去重。\n// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int dx[8] = {2, 1, -1, -2, -2, -1, 1, 2}, dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};int n, m;int a[N], b[N];  // 存储棋子的放置位置unordered_map&lt;int, unordered_set&lt;int&gt; &gt; occupation;bool check(int x, int y) {    // 如果超出范围    if (x &lt; 1 || x &gt; N || y &lt; 1 || y &gt; N)        return false;    return true;}void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++) {        cin &gt;&gt; a[i] &gt;&gt; b[i];        // 将棋子的位置标记为已占用        occupation[a[i]].insert(b[i]);    }    // 存储每一个棋子的攻击范围    for (int i = 1; i &lt;= m; i++) {        for (int j = 0; j &lt; 8; j++) {            int next_a = a[i] + dx[j];            int next_b = b[i] + dy[j];            if (check(next_a, next_b)) {                occupation[next_a].insert(next_b);            }        }    }    // 开始计算总共被占用了多少位置    LL oc = 0;    for (auto [x, y] : occupation)        oc += (LL)y.size();    // 计算剩下了多少位置    cout &lt;&lt; (LL)n * n - oc &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n方法 2：（好写一些）set&lt;pair&lt;int,int&gt;&gt; 可以自动对整数对去重。但是 unordered_set&lt;pair&lt;int,int&gt;&gt;  不行。\n// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int dx[8] = {2, 1, -1, -2, -2, -1, 1, 2}, dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};int n, m;int a[N], b[N];  // 存储棋子的放置位置set&lt;PII&gt; occupation;bool check(int x, int y) {    // 如果超出范围    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n)        return false;    return true;}void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++) {        cin &gt;&gt; a[i] &gt;&gt; b[i];        // 将棋子的位置标记为已占用        occupation.insert({a[i], b[i]});    }    // 存储每一个棋子的攻击范围    for (int i = 1; i &lt;= m; i++) {        for (int j = 0; j &lt; 8; j++) {            int next_a = a[i] + dx[j];            int next_b = b[i] + dy[j];            if (check(next_a, next_b))                occupation.insert({next_a, next_b});        }    }    // 计算剩下了多少位置    LL res = (LL)n * n - occupation.size();    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - Many Segments 2Problem：D - Many Segments 2\n贪心\n题目：给定长度为  的两个正整数数列  和  \n给定正整数 \n求出满足下面条件的整数对  的个数。\n\n\n区间  不会完整的包含区间 \n\n约束条件：\n\n思路：如果我们锁定一个 ，那么  最多可以取到那些  的区间的右端点的最小值-1\n做法：从大到小枚举 ，对于每个 ，统计那些  的区间的右端点的最小值\n优化：双指针。从大到小枚举  的时候， 的区间会逐渐变多，所以统计右端点的最小值，实时更新即可。\n我们先说明一个细节：\n例如：当前区间为 ，那么以  为左端点，不完全包含  的区间有多少个：4 个，分别是  这四个。这个数量刚好对应于  的  数量。\n也就是说，如果定好了左边界 ，如果右边完全没有区间，那结果的数量刚好对应于  的数量\n依次为基础，我们就可以逐渐的更新出所有的结果了。\n时间复杂度为 \n// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int MAX_N = 2e5 + 10;struct node {    int l, r;} a[MAX_N];int n, m;        // n是区间数量，m是范围上限int ans[MAX_N];  // 区间最近右端点long long tot;   // 累计最终答案的变量bool cmp(node x, node y) {    return x.l &gt; y.l;  // 按照左端点降序排序}void solve() {    // 输入部分    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;  // 读入n个区间的左右端点    // 排序 nlogn（这里其实排不排序对结果都没有影响）    // sort(a + 1, a + n + 1, cmp);  // 将区间按左端点降序排序    // 初始化ans数组    for (int i = 1; i &lt;= m + 1; i++)        ans[i] = m + 1;  // 初始化为最大可能值m+1(对应右开区间)    // 第一次处理：对于每个位置，找到以该位置为左端点的区间中，右端点最小的值。O(n)    for (int i = 1; i &lt;= n; i++)        ans[a[i].l] = min(ans[a[i].l], a[i].r);    // 第二次处理：从右向左维护最小值 O(m)    for (int i = m; i &gt;= 1; i--) {        ans[i] = min(ans[i], ans[i + 1]);  // 确保右边的值不会比当前值小        tot += (ans[i] - i);  // 累加每个位置到其对应右端点的距离    }    cout &lt;&lt; tot &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Permute K times 2Problem：E - Permute K times 2\n（TODO）\n题目：给定一个  的排列 \n执行下面操作 K 次：\n\n将  更新到 \n\n输出最后的  排列\n约束条件：\n\n\n\n思路：这道题太抽象了，我还没理解，暂时先空下。\n// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, p[200100];              // n是数组长度，p存储置换数组long long k;                   // k表示操作次数int cnt[200100], ans[200100];  // ans存储最终答案bool vis[200100];              // 记录某个位置是否被访问过// 快速幂，计算 a^k %m 的值long long fpow(long long a, long long b, long long m) {    long long ans = 1;    while (b) {        if (b &amp; 1)            ans = (ans * a) % m;        b &gt;&gt;= 1;        a = (a * a) % m;    }    return ans;}void solve() {    cin &gt;&gt; n &gt;&gt; k;  // 输入n和k    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; p[i];  // 输入置换数组    // 找循环    for (int i = 1; i &lt;= n; i++) {        if (!vis[i]) {      // 如果当前位置未被访问            vector&lt;int&gt; c;  // 用来存储当前循环中的所有数            int j = i;            while (!vis[j]) {  // 沿着置换一直往下走，直到遇到已访问的数                vis[j] = 1;      // 标记已访问                c.push_back(j);  // 将当前数加入循环                j = p[j];        // 移动到下一个数            }            int len = c.size();          // 循环的长度            int temp = fpow(2, k, len);  // 计算2^k mod len            // 计算k次操作后每个位置的新位置            for (int j = 0; j &lt; len; j++) {                ans[c[j]] = c[(j + temp) % len];            }            // cout &lt;&lt; \"第一次循环：\" &lt;&lt; endl;            // for (auto x : c)            //     cout &lt;&lt; x &lt;&lt; \" \";            // cout &lt;&lt; endl;        }    }    for (int i = 1; i &lt;= n; i++)        cout &lt;&lt; ans[i] &lt;&lt; ' ';  // 输出每个位置在k次操作后的新值}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nF - Avoid Queen AttackProblem：F - Avoid Queen Attack\nTODO\n题目：有一个 N*N 的棋盘。棋盘上放置了 M 个棋子。棋子可以攻击 所在行，列，主次对角线上的任何位置。\n请问棋盘上剩余多少位置不会被攻击到？\n\n\n示例：\n如下图所示的放置条件下，整个棋盘只有 2 个位置是安全的。\n\n约束条件：\n\n\n\n思路：TODO\nG - Edit to MatchProblem：G - Edit to Match\nTrie 树模板题。TODO\n题目：给定 N 个字符串 \n令 ，进行下面两种操作之一\n\n操作 1：删除 T 最后一个字母，cost 为 1\n操作 2：给 T 最后添加一个字母，cost 为 1\n\n求将 T 变为空串或者  中的任何一个串 所付出的最小代价。\n约束条件\n 只包含小写字母\n \n思路：这是一道标准的 Tire 树模板题。\n直观思路：先从  的尾部删除若干字符，删除后应该变成某个  的前缀，再开始添加字符。\n使用字典树 / Tire 树 即可。\n考虑对于 Trie 树上的每个节点，记录其到所有  的节点的最短距离 d。\n这个距离等价于：从这个节点代表的字符串开始，至少添加多少个字符能够到达一个 。\n查询的时候，从  代表的节点不断向上爬，并统计（向上爬的步数+d）的最小值，就是答案。\n// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_g// 这是一道标准的 Trie 树模板题#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int MAX_N = 2e5 + 10;int son[MAX_N][26], d[MAX_N], idx;int n;string s[MAX_N];void insert(string s) {    int p = 0;  // 从根节点开始。根节点的 idx 为 0    // 更新根节点到某个字符串结尾的最短距离    // 注：d 表示当前节点到某个字符串结尾的最短距离    // 注：s.size() 是一个 unsigned 整数，在 min 里使用要 int 强制转换一下    d[p] = min(d[p], (int)s.size());    // 挨个遍历字符串的每个字符    for (int i = 0; i &lt; s.size(); i++) {        int u = s[i] - 'a';        if (!son[p][u]) {            son[p][u] = ++idx;            d[idx] = INT_MAX;        }        p = son[p][u];        // 更新 d        d[p] = min(d[p], (int)s.size() - i - 1);    }}int query(string s) {    int p = 0;    int ans = s.size();    for (int i = 0; i &lt; s.size(); i++) {        int u = s[i] - 'a';        if (!son[p][u])            break;        p = son[p][u];        // 统计答案        ans = min(ans, (int)s.size() - i - 1 + d[p]);    }    return ans;}void solve() {    cin &gt;&gt; n;    d[0] = INT_MAX;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; s[i];        int cur_ans = query(s[i]);        insert(s[i]);        cout &lt;&lt; cur_ans &lt;&lt; endl;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 378 Summary","url":"/2024/blog/58127/","content":"本文是 AtCoder Beginner Conteset（ABC）378 的总结笔记。\n\n\nA - PairingProblem：A - Pairing\n省略。\n// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int f[4];void solve() {    for (int i = 0; i &lt; 4; i++) {        int c;        cin &gt;&gt; c;        f[c]++;    }    int res = 0;    for (int i = 1; i &lt;= 4; i++)        res += f[i] / 2;    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nB - Garbage CollectionProblem：B - Garbage Collection\n模拟题。\n省略。\n// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 110;int q[N], r[N];int n, Q;void solve() {    // 读入数据    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; q[i] &gt;&gt; r[i];    cin &gt;&gt; Q;    for (int i = 1, t, d; i &lt;= Q; i++) {        cin &gt;&gt; t &gt;&gt; d;        int tmp = d % q[t];        // 如果 tmp 在 r[t] 前面，说明本轮就可以扔        if (tmp &lt;= r[t])            cout &lt;&lt; d + (r[t] - tmp) &lt;&lt; endl;        // 否则要等到下一轮才能扔        else            cout &lt;&lt; d + q[t] - tmp + r[t] &lt;&lt; endl;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - RepeatingProblem：C - Repeating\nSTL\n输出一个数字前面，离他最近的相同数字的位置。没有就输出 -1。\n思路非常的简单，使用一个 unordered_map 来存储每个数字的出现位置。\n// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, a;unordered_map&lt;int, int&gt; q;void solve() {    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; a;        if (!q.count(a))            cout &lt;&lt; -1 &lt;&lt; \" \";        else            cout &lt;&lt; q[a] &lt;&lt; \" \";        q[a] = i;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - Count Simple PathsProblem：D - Count Simple Paths\nDFS。\n一道非常标准的 DFS 题目。难度不大。\n// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 15;string g[N];    // 存储网格bool st[N][N];  // 存储遍历状态int n, m, k;int res;int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};void dfs(int x, int y, int k) {    if (k == 0) {        res++;        return;    }    for (int i = 0; i &lt; 4; i++) {        int a = x + dx[i], b = y + dy[i];        if (a &lt; 1 || a &gt; n || b &lt; 1 || b &gt; m)            continue;        if (g[a][b] == '#' || st[a][b])            continue;        st[a][b] = true;        dfs(a, b, k - 1);        st[a][b] = false;    }}void solve() {    // 读入数据，1-base    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; g[i];        g[i] = \" \" + g[i];    }    // 对于每个点都 DFS 一遍    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= m; j++) {            if (g[i][j] == '#')                continue;            st[i][j] = true;            dfs(i, j, k);            st[i][j] = false;        }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Mod Sigma ProblemProblem：E - Mod Sigma Problem\n推公式 + 树状数组BIT\n题目：给定一组长度为  的序列 ，给定一个正整数 。\n求 。\n约束条件：\n\n\n思路 ：本题整体需要解决下面两个问题：\n问题 1：公式化简我们定义带模前缀和为 \n那么我们就可以将原公式转化为 \n根据常用的知识点：\n\n，我们就可以将 mod 符号从公式中去除掉，原公式转化为： \n\n\n备注：照理说前缀和中， 是单调递增的，为什么会出现逆序对呢？\n本题中使用的是带模前缀和，所以真实的  值会呈现周期性的变化，当超过  时候，又会跳回到一个比较小的数值范围，所以就可能出现  的情况出现，就对应了本题中需要加入一个偏置 M 把结果“扳正”的情况。\n\n从上面公式可以发现，公式最后可以被拆成 3 个部分：\n\n：直接使用预处理好的带模前缀和计算，时间复杂度为 \n\n：类似于前缀和的前缀和，拆开之后可以发现下图规律。化简结果为：。时间复杂度 。\n\n\n：问题就转化为，如何快速求出带模前缀和 s 的所有逆序对数量？ 使用树状数组 BIT 来解决。\n\n\n问题 2：使用 BIT 求逆序对逆序对的定义是：找到所有的  使得  并且 。\n如何使用 BIT 求逆序对的数量呢？\n假设从左向右遍历数组，当处理到  的时候，数组  都已经被放入了 BIT 中。将数字  作为 index，将出现次数作为 BIT 内存的值。我们可以很容易就求出，已经存入的数字中，比  小的数字有  个。相应的，比  大的数字数量为 \n这一步的时间复杂度为 \n总结：本题的整体思路为：首先将公式进行推到化简，可以发现分别求出三个部分的值就可以得出最终的结果。最麻烦的是如何求整体的逆序对数量，这里使用了 BIT 的数据结构。\n整体的时间复杂度为 。\n// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n, m;int a[N];   // 储存原数组int s[N];   // 储存：带模前缀和int tr[N];  // BITint lowbit(int x) {    return x &amp; -x;}// 更新 BIT 的值void add(int x, int k) {    x++;    for (int i = x; i &lt;= N; i += lowbit(i))        tr[i] += k;}// 求前x个数的数量和int sum(int x) {    x++;    int res = 0;    for (int i = x; i; i -= lowbit(i))        res += tr[i];    return res;}void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; a[i];        // 预处理带模前缀和        s[i] = (s[i - 1] + a[i]) % m;    }    LL res = 0;    // 计算公式的第一部分    for (int r = 1; r &lt;= n; r++)        res += 1ll * s[r] * r;    // 计算公式的第二部分    for (int l = 1; l &lt;= n; l++)        res -= 1ll * s[l - 1] * (n - l + 1);    // 计算逆序对    LL cnt = 0;    for (int i = 1; i &lt;= n; i++) {        cnt += (i - 1 - sum(s[i]));        add(s[i], 1);    }    // 计算公式第三部分    res += 1ll * m * cnt;    // 输出结果    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nF - Add One Edge 2Problem：F - Add One Edge 2\n题目：给定一个树，有 N 个节点，N-1 条边。\n给树增加一条边，能把树变成恰好带一个环的图。\n请问有多少个图满足条件：简单图，环上的所有顶点读数为 3。\n约束条件：\n\n思路：这道题目结论比较暴力：\n​\t直接找度数为  的连通块，然后向外找度数为  的点。假设度数为  的点数量为 ，那么这些度数为  的点直接两两相连，都能形成题目要求的环。形成环的数量为 \n由于是把所有的点都看过，所以极限状态下的时间复杂度为 。\n\n\n// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_f#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10, M = 4e5 + 10;int h[N], e[M], ne[M], idx;  // 存储图int n;int deg[N];  // 记录度数bool st[N];  // 记录是否被看过int cnt;     // 记录点的数量LL res;      // 记录结果// 建图加边void add(int a, int b) {    e[idx] = b;    ne[idx] = h[a];    h[a] = idx++;}// DFSvoid dfs(int now, int fa = 0) {    // 如果当前点度数不为 3    if (deg[now] != 3) {        // 如果度数是 2，就计数        cnt += (deg[now] == 2);        return;    }    // 此点标记    st[now] = true;    // 看一下周围的点    for (int i = h[now]; i != -1; i = ne[i]) {        int next = e[i];        // 如果是来时的点就跳过        if (next == fa)            continue;        // 向下搜        dfs(next, now);    }}void solve() {    // h 数组初始化    memset(h, -1, sizeof h);    // 读入数据，同时预处理各个节点的度数    cin &gt;&gt; n;    for (int i = 1; i &lt;= n - 1; i++) {        int u, v;        cin &gt;&gt; u &gt;&gt; v;        add(u, v), add(v, u);        deg[u]++, deg[v]++;    }    // 依次遍历每个节点    for (int i = 1; i &lt;= n; i++) {        // 度数不为 3，直接跳过        if (deg[i] != 3)            continue;        // 如果这个点已经看过了，跳过        if (st[i])            continue;        // 计算当前连通块，周围度数为 2 的点的数量        cnt = 0;        dfs(i);        res += 1ll * cnt * (cnt - 1) / 2;    }    // 输出结果    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 379 Summary","url":"/2024/blog/29442/","content":"本文是 AtCoder Beginner Conteset（ABC）379 的总结笔记。\n\nA - CyclicProblem：A - Cyclic\n太简单，省略。\n// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII; string s;void solve() {    cin &gt;&gt; s;    cout &lt;&lt; s[1] &lt;&lt; s[2] &lt;&lt; s[0] &lt;&lt; \" \" &lt;&lt; s[2] &lt;&lt; s[0] &lt;&lt; s[1] &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n\n\nB - StrawberriesProblem：B - Strawberries\nSTL + 贪心。\n// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;int n, k;void solve() {    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;    string gd(k, 'O');  // 健康牙齿的 pattern    string bd(k, 'X');  // 蛀牙的 pattern    int res = 0;    // 找健康牙齿的 pattern    while (s.find(gd) != s.npos) {        s.replace(s.find(gd), k, bd);  // 替换成蛀牙 pattern        res++;                         // 计数    }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n\n\nC - Sowing StonesProblem：C - Sowing Stones\n推公式\n题目：编号  的  个格子排成一列。其中  个格子有石子，格子  含有  个石子。\n执行下面操作任意次（可以为 0）\n\n如果  格子有石子，就从  移动一个石子到 \n\n让  个格子恰好每个只有一个石子，则最少进行多少次操作。如果不能，输出 -1\n约束条件：\n\n\n \n \n \n思路：这道题思路有些抽象。\n\n我们希望通过若干次操作，使每个格子中都恰好有  个石子。\n\n​\t那么首先必须保证：石子的总量等于 N。\n​\t其次，必须保证：前  个格子中，至少有  个石子才能填满前面的空位。要求初始分布中的石子满足这个要求。即：如果从前往后看到  格子时，已累计的石子数量少于  时，就无法填满前面的格子。\n\n这里引入一个概念：位置和\n\n​\t如果一个石子在位置  上，那么这颗石子对位置和的贡献就是 \n​\t每进行一次操作，就会使某一颗石子的位置编号增加 。相当于是这颗石子从位置  移动到了 ，相应的对位置和的贡献从  变成了 ）\n​\t意味着：如果初始位置和是 ，最终位置和是 ，那么要从  增加到 ，就必须执行  次增加位置和  的操作。\n\n如何求操作次数呢？\n\n​\t初始状态下，石子的位置和为：\n​\t最终状态下，石子的位置和为：\n​\t每一次操作是将一颗石子从位置  移动到 ，相当于是位置和增加 \n​\t因此为了从初始位置和变成最终位置和，需要的操作次数是：\n总时间复杂度为 ，前半部分是排序的复杂度，后半部分是从头到后遍历一次。\n备注：为什么会引入位置和这个概念呢？\n综上思路，代码如下：\n// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;LL n, m;struct Node {    LL x;  // 存储位置    LL a;  // 存储石子数量} stone[N];bool cmp(const Node&amp; a, const Node&amp; b) {    return a.x &lt; b.x;}void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; m; i++)        cin &gt;&gt; stone[i].x;    for (int i = 0; i &lt; m; i++)        cin &gt;&gt; stone[i].a;    // 升序排列    sort(stone, stone + m, cmp);    LL sum = 0;      // 记录石子数量的累计和    LL pos_sum = 0;  // 记录累计的位置和    for (int i = 0; i &lt; m; i++) {        // 如果石子的累计数量 无法填满前面的空格，结束程序        if (sum &lt; stone[i].x - 1) {            cout &lt;&lt; -1 &lt;&lt; endl;            return;        }        sum += stone[i].a;                   // 更新石子数量的累计和        pos_sum += stone[i].x * stone[i].a;  // 更新累计的位置和    }    // 如果石子数量不对    if (sum != n) {        cout &lt;&lt; -1 &lt;&lt; endl;        return;    }    // 输出结果    cout &lt;&lt; n * (n + 1) / 2 - pos_sum &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - Home GardenProblem：D - Home Garden\n队列\n题目：高桥有很多花盆。最开始没有种植物。\n按照顺序处理  次询问。询问有下面三种：\n\n1 ：准备一个空花盆，种一棵植物，初始高度为 \n2 T ：等待  天。这之后，所有的植物高度都会增加 \n3 H：收割所有高度高于  的植物，并输出收割了多少。\n\n约束条件： \n\n思路：两个核心的思想：\n​\t先种的植物肯定先被收获。（后种的植物不可能比前面种的植物长得更高）。先进先出就可以使用队列。\n​\t队列里面存什么？存种下的时间 。那么经过一段时间后，现在的时间  减去种下的时间 ，差值就是植物的高度 。满足条件就可以 pop（也就是收割）。\n综上：使用队列来管理种入的时间。并额外维护一个当前的时间。\n整体的时间复杂度为  ，同时所有的数据最多进队出队仅一次。\n// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int q;int op;LL x;void solve() {    cin &gt;&gt; q;    queue&lt;LL&gt; Q;  // 队列    LL now = 0;   // 记录当前时间    while (q--) {        cin &gt;&gt; op;        // 种植物        if (op == 1) {            Q.push(now);        }        // 等待 x 天        else if (op == 2) {            cin &gt;&gt; x;            now += x;        }        // 收割高于 x 的植物        else {            cin &gt;&gt; x;            int res = 0;            while (Q.size() &amp;&amp; now - Q.front() &gt;= x) {                res++;                Q.pop();            }            cout &lt;&lt; res &lt;&lt; endl;        }    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Sum of All SubstringsProblem：E - Sum of All Substrings\n题目：给定长度为  的字符串 ，只包含数字 \n对于每一个整数对 ，定义  为  的从  到  的子串转化为整数后得到的值。\n求 \n约束条件：\n思路：直观来看有两种思路，下面将分别介绍：\n思路 1：看字符串中的每一位对结果的贡献我们举如下的例子进行分析：\n\n\n从上面的例子我们可以分析出：\n\n第一位 ：能构成的子串只有 3，为最终的结果做出的贡献是 \n第二位 ：与前面的各个位置构成的子串是 37 7，相加的结果可以转换为 \n第三位 ：与前面的各个位置构成的子串是 379 79 9，相加的结果可以转换为 \n最后所有相加得 ，刚好是正确的结果\n\n我们可以发现，在前一个位数中计算出来的结果，可以在下一位中乘以 10 倍，加上当前位置数字和出现次数的乘积，就是本轮结果为最终答案做出的贡献。\n由于原字符串数字位数非常的大，所以要使用高精度来进行结算。\n但是分析可知，时间复杂度非常的巨大，是 ，在本题目会超时。\n思路 2：看结果中的每一位，是从字符串哪些地方来的简单来说，我们可以分析一下结果中的个位，十位和百位的数字，都是从原字符串中的什么地方贡献出来的。\n\n\n根据上面的例子，我们可以分析出结果的每一位，是由原字符串的哪些部分贡献出来的。\n很容易发现，绿色的部分，实际上是前缀和。\n本题可以视为是 C 题 “位置和” 思路的延续。最终时间复杂度为 。\n// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 22e6 + 10;LL a[N];  // 存储字符串每一位的原数字LL b[N];  // 存储前缀和int n;    // 字符串长度string s;void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; s;    // 将每一位转化为数字，存在 a 数组中    // 并且将 0-base 转化为 1-base    for (int i = 1; i &lt;= n; i++)        a[i] = s[i - 1] - '0';    // 计算每一位，对该位置的权重    for (int i = 1; i &lt;= n; i++)        b[i] = a[i] * i;    // 计算前缀和    for (int i = 1; i &lt;= n; i++)        b[i] += b[i - 1];    // 从后往前，对每一位进行大数进位    for (int i = n; i &gt;= 1; i--) {        // 计算进位        b[i - 1] += b[i] / 10;        // 求出当前位的数值        b[i] %= 10;    }    // b[0] 存储最后的进位    if (b[0] != 0)        cout &lt;&lt; b[0];    // 从高位到低位输出    for (int i = 1; i &lt;= n; i++)        cout &lt;&lt; b[i];    cout &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nF - Buildings 2Problem：F - Buildings 2\n单调栈 + 二分\n题目：有编号  的  栋建筑，分别有不同的高度 。\n对于整数对 ，如果  和  之间，没有比  高的建筑，那么可以从建筑  看到建筑 。\n给定  个查询，每个查询中给定一个整数对 ，求出  后面，能同时被  和  都看到的建筑物的数量。\n约束条件：\n\n\n思路：（备注：本题我还没有弄懂，就暂时先把代码存起来！）\n题目要求，如果  后面的一栋楼 ，需要同时满足下面两点：\n\n从  能看到 \n从  能看到 \n\n本题是“可见楼”问题。许多“可见楼” 问题都可以用单调栈（Monotonic Stack）来做快速处理。\nTODO\n// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_f#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 1e6 + 10;int n, q;int a[N];     // 存放楼的高度int s[N], t;  // s[] 用作单调栈, t 表示栈的大小(或当前栈顶位置)int ans[N];   // 存储最终结果vector&lt;PII&gt; query[N];  // 存储所有左端点为i的查询void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; q;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    // 读入查询    for (int i = 1; i &lt;= q; i++) {        int l, r;        cin &gt;&gt; l &gt;&gt; r;        /*        这里的存储方式很技巧：            index：查询的左端点            value：pair 存储查询的右端点 和 查询编号        */        query[l].push_back({r, i});    }    // 从后往前看每一栋楼    for (int i = n; i &gt; 0; i--) {        // 取出来左端点为 i 的所有查询        for (auto p : query[i]) {            // 在单调栈 s 里二分，找到大于 r 的最小值            int L = 1, R = t;            while (L &lt; R) {                int mid = (L + R + 1) / 2;                if (s[mid] &gt; p.first)                    L = mid;                else                    R = mid - 1;            }            // 说明无解            if (s[L] &lt;= p.first)                ans[p.second] = 0;            // L 就是结果            else                ans[p.second] = L;        }        while (t &amp;&amp; a[s[t]] &lt; a[i])            t--;        s[++t] = i;    }    for (int i = 1; i &lt;= q; i++)        cout &lt;&lt; ans[i] &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n\n\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 380 Summary","url":"/2024/blog/4952/","content":"本文是 AtCoder Beginner Conteset（ABC）380 的总结笔记。\n\n\nA - 123233Problem：A - 123233\n题目：给定一个 6 位整数 。判断这个整数内是否刚好出现了  次 1,  次 2,  次 3。\n思路：按照字符串读入，直接排序，看结果和 122333 是否相同即可。\n// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;// 无脑写法void solve1() {    string s;    cin &gt;&gt; s;    int a = 0, b = 0, c = 0;    for (auto x : s) {        if (x == '1')            a++;        if (x == '2')            b++;        if (x == '3')            c++;    }    if (a == 1 &amp;&amp; b == 2 &amp;&amp; c == 3)        cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else        cout &lt;&lt; \"No\" &lt;&lt; endl;}// 推荐写法：void solve2() {    string s;    cin &gt;&gt; s;    sort(s.begin(), s.end());    cout &lt;&lt; (s == \"122333\" ? \"Yes\" : \"No\") &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    // solve1();  // 解法 1    solve2();  // 解法 2    return 0;}\n\nB - Hurdle ParsingProblem：B - Hurdle Parsing\n题目：给定一个字符串，仅由 | 和 - 构成。输出两个 | 之间 - 的数量。\n思路：维护一个变量 now：\n当遇到 - 时 now 自增计数；\n当遇到 | 时保存 now 的值，并清零。\n// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;// 双指针做法void solve1() {    string s;    cin &gt;&gt; s;    vector&lt;int&gt; res;    int last = 0;    for (int i = 1; i &lt; s.size(); i++) {        int j = i;        while (j &lt; s.size() &amp;&amp; s[j] != '|')            j++;        res.push_back(j - last - 1);        i = j;        last = j;    }    for (auto x : res)        cout &lt;&lt; x &lt;&lt; \" \";    cout &lt;&lt; endl;}// 推荐写法：更具有编程思维void solve2() {    string s;    cin &gt;&gt; s;    vector&lt;int&gt; res;    int now = 0;    for (int i = 0; i &lt; s.size(); i++) {        if (s[i] == '|')            res.push_back(now), now = 0;        else            now++;    }    for (int i = 1; i &lt; res.size(); i++)        cout &lt;&lt; res[i] &lt;&lt; \" \";    cout &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    // solve1();    solve2();    return 0;}\n\nC - Move SegmentProblem：C - Move Segment\n题目：给定长度为  的字符串 ，仅由 0 和 1 构成。\n把第  个 1 block 移动到第  个 1 block 后面，重新输出字符串。\n思路：解法 1：按照块来寻找。每次找到当前 1 block 的起点 st 和终点 ed，同时保存上一个 1 block 的起点 last_st 和终点 last_ed。数到第  个 1 block 的时候，使用 substr 将字符串重新拼接输出即可。\n\n\n解法 2：将原字符串整理到一个 vector&lt;PII&gt; 中。每个 PII 元素同时保存了出现的字符 和 出现的次数。\n只需将第  次出现 1 和他前面的元素交换位置，重新输出即可。\n\n\n// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;// 解法 1：使用字符串拼接void solve1() {    int n, k;    cin &gt;&gt; n &gt;&gt; k;    string s;    cin &gt;&gt; s;    string res;    int last_start = 0, last_ed = 0;    int start = 0, ed = 0;    int cnt = 0;    for (int i = 0; i &lt; s.size(); i++) {        int j = i;        // 找第一次 1 出现的起点        while (j &lt; s.size() &amp;&amp; s[j] != '1')            j++;        start = j;        // 找 1 出现的终点        while (j &lt; s.size() &amp;&amp; s[j] == '1')            j++;        ed = j - 1;        if (cnt == 0) {            last_start = start, last_ed = ed;        }        cnt++;        if (cnt == k) {            res = s.substr(0, last_ed + 1) + s.substr(start, ed - start + 1) +                  s.substr(last_ed + 1, start - last_ed - 1) + s.substr(ed + 1);            break;        }        i = j - 1;        if (cnt &gt; 1) {            last_start = start, last_ed = ed;        }    }    cout &lt;&lt; res &lt;&lt; endl;}// 解法 2：void solve2() {    int n, k;    string s;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;    s += \".\";  // 技巧：防止越界，保证最后一段也被记录    vector&lt;PII&gt; v;    int now = s[0], num = 0;    for (int i = 0; i &lt; s.size(); i++) {        if (s[i] == now)            num++;  // 计算段内长度        else {            v.push_back({now - '0', num});  // 记录这一段的数据:{符号，长度}            now = s[i], num = 1;        }    }    int cnt = 0;    for (int i = 0; i &lt; v.size(); i++) {        // 找到第 k 段为 1 的位置        if (v[i].first == 1) {            cnt++;            if (cnt == k)                // 交换位置                swap(v[i], v[i - 1]);        }    }    // 重新输出    for (auto x : v) {        for (int i = 0; i &lt; x.second; i++)            cout &lt;&lt; x.first;    }    cout &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    // solve1();    solve2();    return 0;}\n\nD - Strange MirroringProblem：D - Strange Mirroring\n递归\n题目：给定一个字符串 ，包含大小写字母。\n对  执行下面操作  次。\n创建字符串 ，是将  中的大小写颠倒。然后将  接到  后面。\n进行  次查询：返回  的第  个字母。\n约束条件： is a string consisting of uppercase and lowercase English letters, with length between  and , inclusive.\n and  are integers.\n\n\n思路：这道题思路很抽象。如下图，以 aBd 为例。\n可以发现经过  次操作后，字符串总长度变为了 。\n对于查询位置 x 的字符，我们总是能够找到 x 前面距离最近的 ，计算出与他的距离 L，我们就能推导出它在上一步操作中的位置。以此为递归的依据，最终能够找到它在原始字符串中的位置。\n根据记录的跳转次数：\n如果是奇数次，则发生大小写转换；\n如果是偶数次，则保持原样。\n因此，对于任意大的数字，都可以在  的时间复杂度内完成单次查询。\n完成  次查询总时间复杂度为 。\n\n// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_d// 这是一道非常典型的递归题目#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;int t;// 大小写转换// ascii 码中：A 为65，a 为 97，相差 32char change(char ch) {    return ch &gt;= 'a' ? (ch - 32) : (ch + 32);}// 递归char f(LL x, bool is_reverse) {    // 如果已经到了最前面    if (x &lt;= s.size()) {        // 如果需要翻转        if (is_reverse)            return change(s[x - 1]);        // 不需要翻转        else            return s[x - 1];    }    LL k = s.size();    // 找到距离 x 左边最近的倍数    while (k * 2 &lt; x)        k *= 2;    // 减去这个长度，向前找    return f(x - k, !is_reverse);}void solve() {    cin &gt;&gt; s &gt;&gt; t;    while (t--) {        LL x;        cin &gt;&gt; x;        cout &lt;&lt; f(x, false) &lt;&lt; \" \";    }    cout &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - 1D Bucket ToolProblem：E - 1D Bucket Tool\n并查集处理区间染色问题。\n题目：有编号  的  个格子排成一行。每个格子的初始颜色为  。\n给定  次查询，查询有下面两种情况：\n1 x c ：把 x 能到达的所有格子都涂成 c 颜色。\n2 c：打印颜色为 c 的格子的数量。\n约束条件：\n\n……\n思路：使用并查集来处理区间染色问题。\n并查集在记录连通块的同时，还要维护额外的三个数组值：\n\n区间的左端点 l\n\n区间的右端点 r\n\n集合内部的节点数 cnt\n\n\n详细参照下面代码：\n// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_e// 使用并查集处理区间染色问题#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e6 + 10;// 节点的父节点，每个集合的节点数，集合的最左端点，集合的最右端点int fa[N], cnt[N], l[N], r[N];int color[N];      // 节点 i 的颜色int color_cnt[N];  // 颜色 i 的数量int n, q;// 查找节点 x 所属的集合int _find(int x) {    // 如果 x 是根节点，就返回 x    // 如果不是，就继续找祖宗。同时进行路径压缩    return x == fa[x] ? x : fa[x] = _find(fa[x]);}// 将 x 所在集合涂成颜色 cvoid paint(int x, int c) {    x = _find(x);                   // 找 x 的祖宗    color_cnt[color[x]] -= cnt[x];  // 从原来的颜色计数中减去整个集合的大小    color[x] = c;                   // 染色    color_cnt[c] += cnt[x];  // 新颜色计数中添加整个集合大小}// 合并两个集合void _union(int x, int y) {    int fx = _find(x), fy = _find(y);  // 找到两个节点的祖宗节点    fa[fx] = fy;                       // fx 的祖宗改为 fy    l[fy] = min(l[fx], l[fy]);         // 更新合并后集合的左边界    r[fy] = max(r[fx], r[fy]);         // 更新合并后集合的右边界    cnt[fy] += cnt[fx];                // 更新合并后集合的节点数量}void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; q;    // 将每个节点    for (int i = 1; i &lt;= n; i++) {        // 初始化：每个节点的颜色，父节点，左边界，右边界        color[i] = fa[i] = l[i] = r[i] = i;        cnt[i] = 1;  // 初始化：每个集合计数，只有一个节点        color_cnt[i] = 1;  // 初始化：每种颜色只有一个节点    }    while (q--) {        int op;        cin &gt;&gt; op;        // 操作 1：染色操作        if (op == 1) {            int x, c;            cin &gt;&gt; x &gt;&gt; c;  // 读入要染色的节点和 x 和目标颜色 c            paint(x, c);    // 染色            // 检查并合并相邻的同色集合            int L = l[_find(x)], R = r[_find(x)];            // 如果左边相邻集合同色            if (color[_find(L - 1)] == c)                _union(L - 1, x);            // 如果右边相邻集合同色            if (color[_find(R + 1)] == c)                _union(R + 1, x);        }        // 操作 2：查询操作        else {            int c;            cin &gt;&gt; c;            cout &lt;&lt; color_cnt[c] &lt;&lt; endl;        }    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 381 Summary","url":"/2024/blog/33621/","content":"本文是 AtCoder Beginner Conteset（ABC）381 的总结笔记。\n\n\nA - 11/22 StringProblem：A - 11/22 String\n题目：判断输入的字符串是否是形如 11/22 或者 111/222 的字符串。\n思路：字符串长度为偶数：肯定不是\n字符串长度为奇数：判断构造的字符串是否和原始字符串相同即可。\n// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n;string s;void solve() {    cin &gt;&gt; n &gt;&gt; s;    if (n % 2 != 1)        cout &lt;&lt; \"No\" &lt;&lt; endl;    else {        string res = string(n / 2, '1') + \"/\" + string(n / 2, '2');        if (s != res)            cout &lt;&lt; \"No\" &lt;&lt; endl;        else            cout &lt;&lt; \"Yes\" &lt;&lt; endl;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nB - 1122 StringProblem：B - 1122 String\n问题：1122  字符串：形如 aabb  aaccdd 的字符串，且各字母在字符串中只出现  次。\n判断输入的字符串是否为  1122  字符串。\n思路：字符串长度为奇数：肯定不是\n字符串长度为偶数：使用 unordered_map 记录每个字符出现的次数。依次判断字符串中， 与  前后两个字符是否相同即可。\n// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;void solve() {    string s;    cin &gt;&gt; s;    int len = s.size();    if (len % 2 != 0)        cout &lt;&lt; \"No\" &lt;&lt; endl;    else {        s = \".\" + s;        unordered_map&lt;int, int&gt; h;        for (int i = 1; i &lt;= len; i++)            h[s[i] - 'a']++;        for (int i = 1; i &lt;= len / 2; i++) {            if (s[2 * i] != s[2 * i - 1] || h[s[i] - 'a'] != 2) {                cout &lt;&lt; \"No\" &lt;&lt; endl;                return;            }        }        cout &lt;&lt; \"Yes\" &lt;&lt; endl;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - 11/22 SubstringProblem：C - 11/22 Substring\n题目：给定字符串 ，求连续的最长的 11/22 子串。\n思路：双指针。\n遍历字符串 ，找到/ 后，用双指针分别向两边前进，找到满足条件的最长长度即可。时间复杂度 。\n// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;int n;void solve() {    cin &gt;&gt; n &gt;&gt; s;    int res = 0;    for (int i = 0; i &lt; s.size(); i++) {        if (s[i] == '/') {            int j = 1;            while (i - j &gt;= 0 &amp;&amp; i + j &lt; n &amp;&amp; s[i - j] == '1' &amp;&amp;                   s[i + j] == '2')                j++;            res = max(res, 2 * j - 1);        }    }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - 1122 SubstringProblem：D - 1122 Substring\n题目：找到字符串  中的最长 1122  连续子串。\n思路：双指针 / 滑动窗口。\n关键是维护 left 和 right 两个指针。随着遍历 left 一点点向右边移动，都能找到一个延伸的最远的 right，使得 right-left 就是子串的最大长度。使用 unordered_map 来维护滑动窗口内部各个字母的数量。\n极端情况下是  的时间复杂度。\n// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_d// 双指针 / 滑动窗口#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int A[N];void solve() {    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)        cin &gt;&gt; A[i];    int res = 0;    unordered_map&lt;int, int&gt; h;    for (int left = 0, right = 0; left &lt; n - 1; left++) {        // 如果出现连续三个以上的相同字符，落到最后一对相同字符上面        while (left + 2 &lt; n &amp;&amp; A[left] == A[left + 1] &amp;&amp;               A[left + 1] == A[left + 2])            left++;        // 如果left 和 left+1 字符相同        if (A[left] == A[left + 1]) {            // 就向右继续搜            if (right &lt; left || (right - left) % 2) {                right = left;                h.clear();            }            // 约束条件：1. 不越界 2. 前后相同 3. 没出现过            while (right + 1 &lt; n &amp;&amp; A[right] == A[right + 1] &amp;&amp; !h[A[right]]) {                h[A[right]] = 2;                // right 向右跳两格                right += 2;            }            res = max(res, right - left);            // left 向右跳            left++;            h[A[left]] = 0;        }    }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - 11/22 SubsequenceProblem：E - 11/22 Subsequence\n题目：给定长度为  的字符串 。有  次查询。每次查询返回  范围内最长的 11/22 子串。子串可以不连续。\n约束条件：\n \n is a string of length  consisting of 1, 2, and /. \n \n, , , and  are integers.\n思路：前缀和 + 2次二分\n对于字符串 S，提前预处理出来1， 2  的前缀和数组 a  和 c。同时用数组 v 记录所有 / 出现的位置。\n对于与每一个查询的 L 与 R，都可以使用二分，在 v 中找到在区间 [L,R] 内出现 / 的一组位置 pos。然后针对每一个pos，都可以用  的时间复杂度计算出在  中出现 1 的个数，和 在  区间中出现 2 的个数。就可以快速的求出来  区间内 11/22 字符串的最大长度了。极端情况下是  的时间复杂度。在  的数据规模下会 TLE。\n\n\n算法的瓶颈在于：需要枚举  区间内的所有 / 出现的位置，在极端情况下是  的时间复杂度。需要对其进行优化。通过下图我们可以发现，在  区间内，左侧的 1 数量在逐渐增多，右侧的 2 数量在逐渐减少。越靠近中央，越是可以得到最优解。此处我们可以再次引入一次二分，找到 左侧1数量 第一次大于等于 右侧2数量 的位置，那么最优解一定在这个位置或者左侧。这样就可以将该步骤时间复杂度限制在 ，总时间复杂度为  ，就可以在限制时间内跑完程序了。\n\n\n// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_e// 前缀和 + 2次二分#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5;int a[N], c[N];  // 分别记录 '1' '2' 的前缀和（出现次数）int n, q;string s;int v[N];  // 存储每个/的位置bool check(int mid, int L, int R) {    // 计算 mid 左边 1 出现的次数    int num_1 = a[mid] - a[L - 1];    // 计算 mid 右边 2 出现的次数    int num_2 = c[R] - c[mid];    return num_1 &gt;= num_2;}void solve() {    cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;    s = \" \" + s;    // 预处理前缀和数组    int cnt = 0;    for (int i = 1; i &lt;= n; i++) {        a[i] = a[i - 1], c[i] = c[i - 1];        if (s[i] == '1')            a[i]++;        if (s[i] == '/') {            v[cnt++] = i;        }        if (s[i] == '2')            c[i]++;    }    int n;    // 存储每个查询    vector&lt;PII&gt; k;    for (int i = 0; i &lt; q; i++) {        int L, R;        cin &gt;&gt; L &gt;&gt; R;        k.push_back({L, R});    }    // 遍历每一个查询    for (auto t : k) {        int res = 0;        int L = t.first, R = t.second;        // 找到 [L,R] 范围内 '/' 的出现范围        int l = lower_bound(v, v + cnt, L) - v;        int r = upper_bound(v, v + cnt, R) - v - 1;        // 如果区间内没有 ‘/’，直接输出 0        if (r &lt; l) {            cout &lt;&lt; 0 &lt;&lt; endl;            continue;        }        // 找到 左侧1数量 大于等于 右侧2数量 的最小值        while (l &lt; r) {            int mid = (l + r) / 2;            if (check(v[mid], L, R))                r = mid;            else                l = mid + 1;        }        int len = min(a[v[l]] - a[L - 1], c[R] - c[v[l]]);        // 看一下前面那个点的情况，取长度的最大值        if (l - 1 &gt;= 0 &amp;&amp; v[l - 1] &gt;= L)            len = max(len, min(a[v[l - 1]] - a[L - 1], c[R] - c[v[l - 1]]));        res = 2 * len + 1;        cout &lt;&lt; res &lt;&lt; endl;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nF - 1122 SubsequenceProblem：F - 1122 Subsequence\n题目：给定长度为  的序列 ，求序列中最长的 1122 字符串子串（可以不连续）。\n约束条件：\n\n思路：\n 小 tips：\n从数据范围可以发现， 的最大值是 20。这是个很有趣的数字。如果是全排列，那么 ，不在考虑范围内。但  就显得刚刚好。 \n经验数值：\n\n\n\n数值\n对应可能的时间复杂度\n\n\n\n10\n 或者  或者  …有很多可能性\n\n\n20\n\n\n\n200 或 300\n\n\n\n500\n\n\n\n1000\n 或 \n\n\n5000\n\n\n\n 或 \n 或 \n\n\n\n\n\n\n\n\n\n\n\n状态压缩 DP。\nTODO。\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 382 Summary","url":"/2024/blog/29505/","content":"本文是 AtCoder Beginner Conteset（ABC）382 的总结笔记。\n\n\nA - Daily CookieProblem：A - Daily Cookie\n省略。\nB - Daily Cookie 2Problem：B - Daily Cookie 2\n把字符串  后面的  个@改成 . 输出。\n// Problem: https://atcoder.jp/contests/abc382/tasks/abc382_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;void solve() {    int n, k;    cin &gt;&gt; n &gt;&gt; k;    string s;    cin &gt;&gt; s;    for (int i = n - 1; i &gt;= 0; i--) {        if (!k)            break;        if (s[i] == '@') {            k--;            s[i] = '.';        }    }    cout &lt;&lt; s &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - Kaiten SushiProblem：C - Kaiten Sushi\n贪心。\n题目：有编号  的  个人，每个人有阈值 ，只吃超过阈值的食物。\n有  的  份寿司，每个寿司有美味度 ，依次经过上面的每个人。只要美味度高于这个人，就会被这个人吃掉。\n输出每份寿司被谁吃掉。\n思路：对于  来说，只要是高于它阈值的寿司，都会被吃掉。所以将所有寿司按照降序排列，从头开始遍历  的各个人即可。\n// Problem: https://atcoder.jp/contests/abc382/tasks/abc382_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n, m;int A[N];PII B[N];    // 存储食物美味度 和 食物编号int res[N];  // 存储每个食物分给了谁// 降序排列bool cmp(const PII&amp; a, const PII&amp; b) {    return a.first &gt; b.first;}void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++)        cin &gt;&gt; A[i];    for (int i = 0; i &lt; m; i++) {        cin &gt;&gt; B[i].first;  // 食物美味度        B[i].second = i;    // 食物编号    }    sort(B, B + m, cmp);          // 降序排列    memset(res, -1, sizeof res);  // res 初始化    for (int i = 0, index = 0; i &lt; n; i++) {        // 只要 接受值 小于等于 食物美味度，就吃掉        // index 如果超出 m 了，食物美味度就是 0，不影响后面的判断，不算越界        while (A[i] &lt;= B[index].first) {            res[B[index].second] = i + 1;            index++;        }    }    // 输出结果    for (int i = 0; i &lt; m; i++)        cout &lt;&lt; res[i] &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - Keep DistanceProblem：D - Keep Distance\nDFS + 剪枝\n题目：打印长度为  并满足下面两个条件的字典序序列 ：\n\n\n\n\n\n\n\n\n思路：题目中有个重要的约束条件：前一个数  与后一个数  距离相差  以上。\n利用这个约束条件可以剪枝 DFS 的递归过程，大大减少时间复杂度。\n// Problem: https://atcoder.jp/contests/abc382/tasks/abc382_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, m;vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; temp;void dfs(int x, int u) {    // 当前序列长度达到n时    if (u == n) {        res.push_back(temp);  // 保存当前解        return;    }    // 超出界限，直接返回    if (x &gt; m)        return;    // 从x+10开始遍历，确保相邻数字差值至少为10    for (int i = x + 10; i &lt;= m - 10 * (n - 1 - u); i++) {        temp.push_back(i);        dfs(i, u + 1);        temp.pop_back();    }}void solve() {    cin &gt;&gt; n &gt;&gt; m;    // 从1开始遍历数列 A 的第一个可能数字    for (int i = 1; i &lt;= m - 10 * (n - 1); i++) {        temp.push_back(i);        dfs(i, 1);  // 已经放入一个数，所以u从1开始        temp.pop_back();    }    // 输出每一组解    cout &lt;&lt; res.size() &lt;&lt; endl;    for (auto&amp; x : res) {        for (auto t : x)            cout &lt;&lt; t &lt;&lt; \" \";        cout &lt;&lt; endl;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Expansion PacksProblem：E - Expansion Packs\n概率题\n题目：有无限个口袋，每个口袋里有  张卡片。第  张卡片位稀有卡的概率为 。\n一个个打开口袋。求累计获得  张稀有卡的时候，打开口袋的期望值。\n限制条件：\n\n\n思路：TODO\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 383 Summary","url":"/2024/blog/58188/","content":"本文是 AtCoder Beginner Conteset（ABC）383 的总结笔记。\n\n\nA - Humidifier 1Problem：A - Humidifier 1\n模拟题。非常的简单。\n// Problem:#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;void solve() {    int n;    cin &gt;&gt; n;    int res = 0, last_t = 0;    for (int i = 1; i &lt;= n; i++) {        int t, v;        cin &gt;&gt; t &gt;&gt; v;        if (res)            res = max(res - (t - last_t), 0);        res += v;        last_t = t;    }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n\n\n\n\nB - Humidifier 2Problem：B - Humidifier 2\n暴力搜索。\n由于数据范围非常小，网格最大也才 ，所以直接暴力枚举两个加湿器的位置，然后暴力计算每个点和加湿器的位置即可。\n// Problem: https://atcoder.jp/contests/abc383/tasks/abc383_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 15;char g[N][N];bool st[N][N];int res;int h, w, d;int check(int a, int b, int x, int y) {    int ans = 0;    for (int i = 0; i &lt; h; i++)        for (int j = 0; j &lt; w; j++)            if (g[i][j] == '.')                if (abs(i - a) + abs(j - b) &lt;= d ||                    abs(i - x) + abs(j - y) &lt;= d) {                    ans++;                }    return ans;}void solve() {    cin &gt;&gt; h &gt;&gt; w &gt;&gt; d;    for (int i = 0; i &lt; h; i++)        for (int j = 0; j &lt; w; j++)            cin &gt;&gt; g[i][j];    // 确定第一台的位置    for (int i = 0; i &lt; h; i++)        for (int j = 0; j &lt; w; j++) {            // 确定第二台的位置            for (int x = 0; x &lt; h; x++)                for (int y = 0; y &lt; w; y++) {                    // 如果是同一个点，跳过                    if (i == x &amp;&amp; j == y)                        continue;                    // 如果两个点都是 地板                    if (g[i][j] == '.' &amp;&amp; g[x][y] == '.') {                        res = max(res, check(i, j, x, y));                    }                }        }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n\n\nC - Humidifier 3Problem：C - Humidifier 3\n图论题目。\n题目本质是在问每个格子到最近的  距离是多少。使用经典的 “虚拟节点” 方法转换为单源最短路问题。我的答案里把 1e6+5 作为了虚拟节点。\n// Problem: https://atcoder.jp/contests/abc383/tasks/abc383_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 1e6 + 10, M = 20 * N;int h[N], e[M], w[M], ne[M], idx;int dist[N];int st[N];int H, W, d;char g[1010][1010];int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};void add(int a, int b, int c) {    e[idx] = b;    w[idx] = c;    ne[idx] = h[a];    h[a] = idx++;}// SPFA 算法void spfa() {    int start = 1e6 + 5;    memset(dist, 0x3f, sizeof dist);    dist[start] = 0;    queue&lt;int&gt; q;    q.push(start);    st[start] = true;    while (q.size()) {        int now = q.front();        q.pop();        st[now] = false;        for (int i = h[now]; i != -1; i = ne[i]) {            int next = e[i];            if (dist[next] &gt; dist[now] + w[i]) {                dist[next] = dist[now] + w[i];                if (!st[next]) {                    q.push(next);                    st[next] = true;                }            }        }    }}void solve() {    // 读入网格数据    cin &gt;&gt; H &gt;&gt; W &gt;&gt; d;    for (int i = 0; i &lt; H; i++)        for (int j = 0; j &lt; W; j++)            cin &gt;&gt; g[i][j];    // 建图    memset(h, -1, sizeof h);    for (int i = 0; i &lt; H; i++)        for (int j = 0; j &lt; W; j++) {            // ‘#’点不建图            if (g[i][j] == '#')                continue;            int now = i * W + j;            // ‘H’点额外添加和虚拟节点 1e6+5 的 0 边权的边            if (g[i][j] == 'H') {                add(1e6 + 5, now, 0), add(now, 1e6 + 5, 0);            }            // 看一下周围四个点能不能建边            for (int k = 0; k &lt; 4; k++) {                int a = i + dx[k], b = j + dy[k];                // 越界                if (a &lt; 0 || a &gt;= H || b &lt; 0 || b &gt;= W)                    continue;                // 遇到 #                if (g[a][b] == '#')                    continue;                // 建边                add(now, a * W + b, 1);            }        }    spfa();    // 遍历，看距离 H 在 d 以内的点有多少    int res = 0;    for (int i = 0; i &lt; H; i++)        for (int j = 0; j &lt; W; j++)            if (g[i][j] != '#' &amp;&amp; dist[i * W + j] &lt;= d)                res++;    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n\n\nD - 9 DivisorsProblem：D - 9 Divisors\n数论题目。\n能满足只有 9 个约数的数字实际上不多。\n\n约数基本定理：\n​\t一个数能被拆成若干个质数乘积的形式 ，那么 N 的约数个数为 。\n\n按照上面定理的格式，9 只能被拆分为  或者  两种可能性。\n\n ：表明数字 ，是某一个质数的 8 次方\n ：表示数字 ，是某两个质数的平方和\n\n思路：\n​\t预处理出来质数表。分成两种情况遍历即可。这道题也并不需要真的预处理出来  这么多数字，只需要计算到  即可。 \n// Problem: https://atcoder.jp/contests/abc383/tasks/abc383_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const LL N = 2e6 + 10;LL primes[N], cnt;bool st[N];LL n;// 线性筛法模板void get_primes(LL x) {    for (LL i = 2; i &lt;= x; i++) {        if (!st[i])            primes[cnt++] = i;        for (LL j = 0; primes[j] * i &lt;= x; j++) {            st[i * primes[j]] = true;            if (i % primes[j] == 0)                break;        }    }}// 计算 x^4 的值LL pow_4(LL x) {    return x * x * x * x;}void solve() {    // 读入数据，计算平方根    cin &gt;&gt; n;    LL intSqrt = sqrt(n) + 1;    // 预处理质数表    get_primes(intSqrt);    // 讨论 1*8 的情况    int res = 0;    for (int i = 0; i &lt; cnt; i++) {        if (pow_4(primes[i]) &lt; intSqrt)            res++;        // 防止溢出，超出界限直接 break，后面的再不算了        else            break;    }    // 讨论 3*3 的情况    for (int i = 0; i &lt; cnt; i++)        for (int j = i + 1; j &lt; cnt; j++) {            LL temp = primes[i] * primes[j];            if (temp &lt; intSqrt)                res++;            // 防止溢出，超出界限直接 break            else                break;        }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Sum of Max MatchingProblem：E - Sum of Max Matching\n题目：给定一个 节点  条边，带正边权的简单无向图。对于从  到  的一条路径，路径权重为该路径经过的所有边的最大值。令  是从  走到  的所有路径的路径权重的最小值。\n给定两个长度为  的序列  和 ， 可以自由排序，求  的最小值。\n关键数据范围： \n \n\n  \n\n \nThe given graph is simple and connected.\nAll input values are integers.\n思路：这道题非常类似于 NOPI2013提高组的题目：506. 货车运输 - AcWing题库\n题目解析： 表示从  走到  的所有路径中，最小的路径权重。例如：\n\n\n如上述例子，有 。\n直觉思路：二分\n对于求类似 “最大值的最小值” 类型的题目，基本都可以使用二分思路来解决。\n对于一个  值，将图中所有边权大于  的边全部删掉，看剩下的图的连通性。\n本题思路：并查集+贪心\n如果我们将所有的边按照边权升序排列，一条边一条边的添加进图。我们希望  的值尽可能的小，意味着需要 A 和 B 中的点尽可能早的进行匹配。那么每次加入一条边，就有可能会合并两个连通块，那么新加入的这条边的边权，一定是两个连通块之间  值的最小值。如果匹配成功了  对，那么就会产生  的  值。\n详细可参考下面的示例：\n\n\n备注：最后实际上生成的图是“最小生成树”，算法类似于 Kruskal 算法。\n// Problem: https://atcoder.jp/contests/abc383/tasks/abc383_e// 并查集 + 贪心#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;struct Edge {    int w;    int u, v;} e[N];bool cmp(Edge&amp; a, Edge&amp; b) {    return a.w &lt; b.w ? true : false;}int A[N], B[N];int cnta[N], cntb[N];  // 连通块中，未匹配的A和B各个元素的数目int p[N];              // 并查集数组，存储每个元素的祖宗元素int n, m, k;// 找到 x 的祖宗节点int find(int x) {    if (p[x] != x)        p[x] = find(p[x]);    return p[x];}// 计算x和y点相连，能匹配成功多少对点int merge(int x, int y) {    // 求 x 和 y 的根节点    int px = find(x), py = find(y);    // 如果相同，说明他们已经在一个连通块了，不能再匹配了    if (px == py)        return 0;    // 把 x 并入 y 中    p[px] = py;    // 将 px 连通块的 AB 计数加到 py 上    cnta[py] += cnta[px];    cntb[py] += cntb[px];    // 合并完成后，看看在 fy 为根的连通块中有多少对可以A与B相匹配    int tmp = min(cnta[py], cntb[py]);    // 匹配完成，把匹配掉的A和B减掉。（因为已经成对了，不是未匹配的状态）    cnta[py] -= tmp;    cntb[py] -= tmp;    // 返回这一次匹配成功了多少个点    return tmp;}void solve() {    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    // 读入所有的边    for (int i = 0; i &lt; m; i++) {        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        e[i] = {c, a, b};    }    // 储存 A 和 B    for (int i = 0; i &lt; k; i++)        cin &gt;&gt; A[i];    for (int i = 0; i &lt; k; i++)        cin &gt;&gt; B[i];    // 并查集初始化    for (int i = 1; i &lt;= n; i++)        p[i] = i;    // 按照边权升序排列    sort(e, e + m, cmp);    // 预处理A和B中，每个元素的数量，存在cnta和cntb中    for (int i = 0; i &lt; k; i++) {        cnta[A[i]]++;        cntb[B[i]]++;    }    // 遍历每一条边    LL res = 0;    for (int i = 0; i &lt; m; i++) {        // 看加入i边后，能匹配多少对        res += merge(e[i].u, e[i].v) * e[i].w;    }    // 输出结果    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nF - DiversityProblem：F - Diversity\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 384 Summary","url":"/2024/blog/54122/","content":"本文是 AtCoder Beginner Conteset（ABC）384 的总结笔记。\n\n\nA - aaaadaaProblem：A - aaaadaa\n签到题。将字符串  中不是 a 的字符全部改成 b。\n// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n;char a, b;string s;void solve() {    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; s;    for (auto&amp; x : s)        if (x != a)            x = b;    cout &lt;&lt; s &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nB - ARC DivisionProblem：B - ARC Division\n模拟题。\n按照题目要求做条件判断即可。\n\n如果参加的是 div1 并且当前 rating 在  之间，就可以计入成绩\n如果参加的是 div2 并且当前 rating 在  之间，就可以计入成绩\n其他情况直接跳过\n\n// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, r;int d, a;bool check_div1(int r) {    if (r &gt;= 1600 &amp;&amp; r &lt;= 2799)        return true;    return false;}bool check_div2(int r) {    if (r &gt;= 1200 &amp;&amp; r &lt;= 2399)        return true;    return false;}void solve() {    cin &gt;&gt; n &gt;&gt; r;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; d &gt;&gt; a;        // 参加 div1，并且 rating 在 [1600,2799] 之间        if (d == 1 &amp;&amp; check_div1(r))            r += a;        // 参加 div2，并且 rating 在 [1200,2399] 之间        else if (d == 2 &amp;&amp; check_div2(r))            r += a;        // 否则跳过        else            continue;    }    cout &lt;&lt; r &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - Perfect StandingsProblem：C - Perfect Standings\n位运算 + STL\n题目：A B C D E 题分别对应 a b c d e 五个分值。\n从只做出 A 题到全部做完 ABCDE ，共有 31 种组合情况。\n按照分值从大到小输出各种做题的可能性，分值相同的时候，按照字典序输出。\n思路：这道题虽然使用最暴力的手工枚举也可以做，但是太过麻烦。下面是更加通用的方法。\n需要解决两个问题：\n\n如何枚举所有的做题状态？\n本题总共有五位，所以可以使用一个五位的二进制数就可以枚举出各个题的解答状态。\n\n如何按照分数降序 和 字典序升序的方式排列。\n使用 struct 的时候，单独定义 cmp 比较算子。\n\n\n// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_c// 位运算#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int a[5];struct Score {    int s;       // 存储分值    int st;      // 存储二进制状态    string str;  // 存储对应的做题方案} s[50];// 自定义算子bool cmp(const Score&amp; a, const Score&amp; b) {    if (a.s != b.s) {        return a.s &gt; b.s;  // s 不同时按 s 降序    }    return a.str &lt; b.str;  // s 相同时按 str 字典序升序}// 将二进制状态转化为字符串string make_str(int x) {    string s = \"\";    for (int i = 0; i &lt; 5; i++)        if (x &gt;&gt; i &amp; 1)            s += 'A' + i;    sort(s.begin(), s.end());    return s;}// 计算当前二进制状态的分值int cal_score(int x) {    int res = 0;    for (int i = 0; i &lt; 5; i++)        if (x &gt;&gt; i &amp; 1)            res += a[i];    return res;}void solve() {    // 读入各个题目的分值    for (int i = 0; i &lt; 5; i++)        cin &gt;&gt; a[i];    // 遍历所有 32 种状态，同时计算 分值 和 对应的字符串    for (int i = 0; i &lt;= 31; i++) {        s[i].st = i;        s[i].s = cal_score(i);        s[i].str = make_str(i);    }    // 排序    sort(s, s + 32, cmp);    // 输出结果（只输出前 31 个结果，第 32 个结果是空集，跳过）    for (int i = 0; i &lt; 31; i++)        cout &lt;&lt; s[i].str &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - Repeated SequenceProblem：D - Repeated Sequence\n思维题\n题目：给定长度为  的序列 。以这组序列为模板，无限重复循环。\n是否能截取连续出子序列，使和恰好为 。\n约束条件\n\n\n思路：根据下图示例，我们可以发现，选取的子段由三部分组成：一个后缀，若干个周期 pattern，一个前缀。\n由于任意的  都是正数，所以我们可以直接知道可以有多少个完整的 pattern，即 。\n如果去除中间重复的 pattern，最后一定会剩下左边的一部分 left 和右边的一部分 right。那么 \n问题转化为，能不能找到一个后缀和一个前缀，使二者的和等于 。\n\n\n最后剩下的部分，和的范围应该是 。\n所以我们依次遍历左边部分的后缀和，同时维护一个 set，判断 set 里面有没有我们想要的值即可。总时间复杂度为 。（或者也可以直接使用二分，也可以达成相同的目的）\n// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int A[N];LL sum[N];LL n, s;set&lt;LL&gt; h;void solve() {    // 读入数据，维护 前缀和 和 set    cin &gt;&gt; n &gt;&gt; s;    for (int i = 1; i &lt;= n; i++) {        cin &gt;&gt; A[i];        sum[i] = sum[i - 1] + A[i];        h.insert(sum[i]);    }    s %= sum[n];    sum[n + 1] = sum[n];    bool can = false;    // 从后往前逐个遍历    for (int i = n + 1; i &gt;= 1; i--) {        // 计算出后缀和        LL left = sum[n + 1] - sum[i - 1];        // 计算出期待的前缀和        LL right = s - left;        // 看是否存在        if (h.count(right))            can = true;        if (h.count(right + sum[n]))            can = true;        if (can)            break;    }    if (can)        cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else        cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Takahashi is Slime 2Problem：E - Takahashi is Slime 2\n优先队列 BFS。本题和 ABC 383 的 E - Sinking Land 题目非常相似。\n题目：给定  的网格。每个网格中有一个数值 。起始点位于 。\n从起点向四方向移动。只有数值  严格小于当前累计值 res 的  的时候，才能吃掉这个格子。\n求最大累加值。\n约束条件：\n\n\n思路：标准的优先队列 BFS 题目。按照题目写即可。\n需要注意的一个细节点：\n​\t题目要求“数值  严格小于当前累计值 res 的  的时候，才能吃掉这个格子”。这里的严格小于应该如何处理。如果直接写 s * X &lt; res 的话，在本题规模下会溢出。这里只需要计算 即可。代码写作 s &lt; (res+X-1)/X 。\n// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_e// 优先队列 BFS#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};const int N = 510;LL g[N][N];LL P, Q;LL H, W, X;LL res;bool st[N][N];// 创建结构体struct Node {    LL x, y, score;    // 重置小于符号（为小根堆做准备）    bool operator&lt;(const Node&amp; a) const { return score &gt; a.score; }};priority_queue&lt;Node&gt; que;void solve() {    // 读入数据    cin &gt;&gt; H &gt;&gt; W &gt;&gt; X &gt;&gt; P &gt;&gt; Q;    for (int i = 1; i &lt;= H; i++)        for (int j = 1; j &lt;= W; j++) {            cin &gt;&gt; g[i][j];        }    // 初始化    que.push((Node){P, Q, g[P][Q]});    st[P][Q] = true;    res = 0;    // 优先队列 BFS    /*        注意：题目中要求，吸收单元格的 score 值必须严格小于 res/X        这里直接使用上取整，即 score &lt;(res+X-1)/X 即可满足要求    */    while (que.size() &amp;&amp; (res == 0 || que.top().score &lt; (res + X - 1) / X)) {        Node now = que.top();        que.pop();        res += now.score;        for (int i = 0; i &lt; 4; i++) {            int a = now.x + dx[i], b = now.y + dy[i];            // 越界            if (a &lt; 1 || a &gt; H || b &lt; 1 || b &gt; W)                continue;            // 已经被看过了            if (st[a][b])                continue;            // 加入优先队列            que.push((Node){a, b, g[a][b]});            st[a][b] = true;        }    }    // 输出结果    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nF - Double Sum 2Problem：F - Double Sum 2\n数论题目。（这道题非常的抽象，很难理解）\n题目：给定正整数 。定义  ：只要  还是偶数，就让他一直除以 ，最终剩下的值作为  的结果。\n给定序列 ，求  的值。\n约束条件：\n\n思路：\n技巧：\t统计顺序的更改。核心思想：本题要求出  个数字的和，如果一个个统计，肯定会超时。可以把数字分成组，一次算出一组的和，最后再相加。\n\n整体思路：\n\n定义  为满足下面条件的所有  对应的  的总和\n\n\n条件 1：\n条件 2： 是  的倍数\n\n​\t也就是说， 是所有满足  的配对  的  的总和。\n\n那么，如果  恰好能被  整除的  的和为 。\n\n​\t备注：这里可能稍微有点难理解。举个例子，一个数  如果能被  整除，那么它一定能被  整除。那么只能被 8 整除的部分的总和就是 \n\n最终所求的答案就是：将所有  的这种“刚好被  除以  次”的和，在分别除以  后再累加起来，即 。\n\n细节问题处理：\n根据上面的思路，于是问题就转变为：如何快速的求出  的值？\n我们可以知道： ，如果直接双层遍历，时间复杂度是  ，显然不行。\n技巧：同余条件  等价于  也就等价于  。\n所以当处理 j 位置时，我们希望知道：\n\n在  的部分中，有多少个  满足 \n在  的时候，若  能够被  整除，则这一对也要计入\n\n为了方便计数求和，我们可以用一个以  为键的 “字典 map” 来维护已经出现过的  的计数和总和。\nmap：\n\n键 key：\n值 value：在当前余数下出现的所有  的个数和总和\n\n因此，当我们要处理  时，先计算出 ，然后在 map 中查找这个 key 是否存在。\n若存在，就可以得到相匹配的 （满足条件的个数） 和  （满足条件的和），就可以快速求出 。\n然后根据前面的公式\n// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_f#include &lt;bits/stdc++.h&gt;using namespace std;// typedef long long LL;#define int long long  // 本题中大量使用 ll，为了方便直接定义为 inttypedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10, M = 2e7 + 10;int n;int a[N];int sum[M];  // 存储累计和，A_i的上限是2e7，所以mp的idx不会超过这个数int cnt[M];  // 存储计数int d[30];   // 存储所有中间的 d 值void solve() {    // 读入原始数据    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    int k = 1;  // 即 2^0    // 遍历阶次    for (int j = 0; j &lt;= 24; j++) {        // 从头遍历数组中的每个数        for (int i = 1; i &lt;= n; i++) {            int key = a[i] % k;            // mp[r]是a[i]%k后余数为r的所有数a[i]的累计和            sum[key] += a[i];            // cnt[r]是a[i]%k后余数为r的所有数出现次数            cnt[key]++;            // 累计获得 d_j 的值            d[j] += sum[(k - a[i] % k) % k] + a[i] * cnt[(k - a[i] % k) % k];        }        // mp 与 cnt 重置        for (int i = 1; i &lt;= n; i++) {            int key = a[i] % k;            sum[key] = 0;            cnt[key] = 0;        }        k = k * 2;    }    // 计算出结果    int res = 0;    k = 1;    for (int i = 0; i &lt;= 24; i++) {        res += (d[i] - d[i + 1]) / k;        k *= 2;    }    cout &lt;&lt; res &lt;&lt; endl;}signed main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 385 Summary","url":"/2024/blog/17255/","content":"本文是 AtCoder Beginner Conteset（ABC）385 的总结笔记。\n\nA - EquallyProblem：A - Equally\n有两种思路。\n\n分成四种情况来讨论\n\n只要 abc 的总和能被 abc 中的最大值整除，就意味着能被分开。（很巧妙）\n\n\n// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int a, b, c;// 解法 1：分成四种情况来讨论void solve1() {    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    if (a + b == c || a + c == b || b + c == a || (a == b &amp;&amp; b == c))        cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else        cout &lt;&lt; \"No\" &lt;&lt; endl;}// 解法 2：只要 sum 能被 abc 中的最大值整除即可void solve2() {    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    int mx = max({a, b, c});    int sum = a + b + c;    if (sum % mx == 0)        cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else        cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve1();    // solve2();    return 0;}\n\nB - Santa Claus 1Problem：B - Santa Claus 1\n模拟题。\n// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 110;char g[N][N];int h, w, x, y;string s;bool st[N][N];int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};int res;// 转换函数：把 UDLR 转换为 idxint trans(char c) {    if (c == 'U')        return 0;    else if (c == 'D')        return 1;    else if (c == 'L')        return 2;    else        return 3;}void solve() {    // 读入数据    cin &gt;&gt; h &gt;&gt; w &gt;&gt; x &gt;&gt; y;    for (int i = 0; i &lt; h; i++)        for (int j = 0; j &lt; w; j++)            cin &gt;&gt; g[i][j];    cin &gt;&gt; s;    // 1-base 转换为 0-base    x--, y--;    // 遍历每个指令    for (auto c : s) {        int d = trans(c);        // 计算下一个点的坐标        int a = x + dx[d], b = y + dy[d];        // 越界        if (a &lt; 0 || a &gt;= h || b &lt; 0 || b &gt;= w)            continue;        // 撞墙        if (g[a][b] == '#')            continue;        // 如果是第一次遇见'@'，计数+1        if (g[a][b] == '@' &amp;&amp; !st[a][b]) {            st[a][b] = true;            res++;        }        // 更新坐标        x = a, y = b;    }    // 输出结果    cout &lt;&lt; x + 1 &lt;&lt; \" \" &lt;&lt; y + 1 &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - Illuminate BuildingsProblem：C - Illuminate Buildings\nDP\n题目：N 栋建筑排成一列。高度为 H_i\n想要给建筑点灯，有下面要求：\n\n选中的建筑物要有相同的高度\n选中建筑物之间间隔相同\n\n求能选出的最多建筑。\n约束条件：\n思路：DP 的最长子序列问题。\n令 f[i][j] 表示：以第 i 个位置结尾，且前后两个相同数字的距离是 j 时，最大长度。\n时间复杂度为 ，本题中为  的时间复杂度。\n// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_c// DP#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 3010;int a[N];int f[N][N];int n, res;void solve() {    // 读入数据    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    // dp 数组初始化    for (int i = 0; i &lt;= n; i++)        for (int j = 0; j &lt;= n; j++)            f[i][j] = 1;    // f[i][j] 表示：以第i个位置结尾，且前后两个相同数字距离是j时，最大长度    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++) {            if (i - j &gt;= 1 &amp;&amp; a[i] == a[i - j])                f[i][j] = max(f[i][j], f[i - j][j] + 1);            res = max(res, f[i][j]);        }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - Santa Claus 2Problem：D - Santa Claus 2\nSTL + 二分\n题目：二维平面上有坐标为  共  个房子。\n最开始，圣诞老人在起点  处，按照序列  方式移动\n\n若  是当前点坐标\n若  是 U，则沿着直线从  移动到 \n若  是 D，则沿着直线从  移动到 \n若  是 L，则沿着直线从  移动到 \n若  是 R，则沿着直线从  移动到 \n\n\n\n求出完成所有移动后，圣诞老人经过的房子的数量。（若多次经过相同房间，只计算 1 次）\n约束条件：\n\n\nThere is no house at .\n\n思路：有两个核心问题：\n\n如何快速知道一次移动中会经过多少个房子\n如何筛选掉已经走过的房子\n\n容易发现，每次的移动都是直上直下或者水平的移动，也就是说在移动的时候，其中一个坐标轴的坐标是固定的。\n解决方法：\n\n维护一个特殊的数据结构：map&lt;int , set&lt;int&gt;&gt;，再使用二分。\n\n举例：对于数据结构 map&lt;int , set&lt;int&gt;&gt; mx 来说，key 存储的是每个房子的 x 坐标，value 存的是相同 x 坐标的所有 y 坐标的值。那么在一次移动中，一定会对应左右端点。那么使用二分在 set 中查找左右端点，中间的值就是经过的点。将这几个点从 set 中清除掉，就实现了只计算一次经过的功能。\n时间复杂度为 ，对应的是 m 次移动，每次移动中会进行两次二分查找。\n// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;using Map = map&lt;int, set&lt;int&gt;&gt;;Map mx, my;vector&lt;int&gt; temp;int n, m;  // 点的数量，移动次数LL x, y;   // 起始坐标LL res;char d;  // 临时变量，记录移动方向LL c;    // 临时变量，记录移动距离//void run(LL x, LL y, LL u, LL v, Map&amp; i, Map&amp; j) {    // 判断点的位置是否合法    if (i[x].empty())        return;    if (abs(x) &gt; 1e9 || abs(y) &gt; 1e9)        return;    temp.clear();    auto bg = i[x].lower_bound(y + u);    auto ed = i[x].upper_bound(y + v);    // 从 bg 到 ed 之间所有的元素都要删除并计数    for (auto it = bg; it != ed; it++) {        res++;        temp.push_back((*it));    }    // 在原始数组中删除经过的点    for (auto p : temp) {        i[x].erase(p);        j[p].erase(x);    }}void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;    for (int i = 1, u, v; i &lt;= n; i++) {        cin &gt;&gt; u &gt;&gt; v;        mx[u].insert(v);  // x 下有多少个 y        my[v].insert(u);  // y 下有多少个 x    }    // 处理所有移动    for (int i = 1; i &lt;= m; i++) {        char d;        cin &gt;&gt; d &gt;&gt; c;  // 读入移动方向和距离        if (d == 'U')            run(x, y, 0, c, mx, my), y += c;        if (d == 'D')            run(x, y, -c, 0, mx, my), y -= c;        if (d == 'L')            run(y, x, -c, 0, my, mx), x -= c;        if (d == 'R')            run(y, x, 0, c, my, mx), x += c;    }    cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Snowflake TreeProblem：E - Snowflake Tree\n贪心\n题目：定义“雪花树”：\n\n整数 x 与 y\n选中一个中心点\n中心点向外连接 x 个节点，作为中间层\n中间层的每个节点，各向外连接 y 个节点，作为最外层\n\n例如：x=4，y=2 的情况为：\n\n\n给定一个1~N 共 N 个节点的树 T，有 N-1 条边。\n若删除部分节点能让这棵树变成“雪花树”，输出最少删除多少个节点。\n约束条件：\n\n思路：我们很容易发现，对于一棵  的 “雪花树”，它所含有的节点数肯定为 ，表示的含义是：中心有 1 个节点，周围有 x 个节点，最外侧有  个节点。\n也就意味着，对于 N 个节点的树，如果能确定下来“雪花树”的尺寸为 ，那么被删掉的节点数就是 。\n问题就转化为了：对于一个中心点，如何求出它的 “雪花树”？使用贪心的思想。\n使用下图举例：\n\n\n我们假设有上面的这棵树。确定中心点 M 后，我们就可以知道中心点周围有多少个点。根据度数，实际就可以知道再向外最多扩展多少个点。 刚好就是扩展点的度数。\n我们将所有的点按照度数大小降序排列。将会依次遍历 EACBD 几个点。\n\n先看 E 点：E 点向外最多扩展 6 个节点，意味着此时生成的 “雪花树” 大小为 \n\n再看 A 点：A 点向外最多扩展 5 个节点，意味着此时生成的 “雪花树” 大小为 \n\n再看 C 点：C 点向外最多扩展 4 个节点，意味着此时生成的 “雪花树” 大小为 \n\n\n​\t……\n通过遍历，我们实际就可以知道能够生成的最大的 “雪花树” 的尺寸了，相应的，也就知道最少删除多少节点，就能生成该 “雪花树” 了。\n时间复杂度为 。最大的瓶颈是排序部分。\n写法 1：数组存图使用数组来存储图（这个写法稍微麻烦一点，但是比 vector 快）\n注意：这里会遇到一个坑：\n​\t如果使用 memset 重置 d 数组，有  的时间复杂度，会导致程序 TLE。但实际上用 cnt 维护 d 的长度，不用重置 d 数组也没有关系。\n// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 3e5 + 10, M = 6e5 + 10;int h[N], e[M], ne[M], idx;  // 存储图int deg[N];                  // 存储所有节点的度数int d[N], cnt;               // 存储中心点周围点的度数int n;// 加边void add(int a, int b) {    e[idx] = b;    ne[idx] = h[a];    h[a] = idx;    idx++;}void solve() {    // h 数组初始化    memset(h, -1, sizeof h);    // 读入边数据，建边，同时计算各个点的度数    cin &gt;&gt; n;    for (int i = 0, a, b; i &lt; n - 1; i++) {        cin &gt;&gt; a &gt;&gt; b;        add(a, b), add(b, a);        deg[a]++, deg[b]++;    }    int res = n;    // 遍历每个点作为中心点    for (int now = 1; now &lt;= n; now++) {        /*            注意：这里有个坑。照理说 d 数组每次都应该清空再用。            但是 memset d 重置为 0 要 O(N) 的时间复杂度。            这里重置 d 的话，就会超时，程序 TLE            实际上使用 cnt 来维护 d 的长度，不用重置也可以。        */        // memset(d, 0, sizeof d);        cnt = 0;        for (int j = h[now]; j != -1; j = ne[j]) {            int next = e[j];       // 获取 now 周围的点            d[cnt++] = deg[next];  // 记录点的度数        }        sort(d, d + cnt, greater&lt;int&gt;());  // 降序排列        // 分别计算“雪花树”的尺寸，更新最少删除点的值        for (int i = 1; i &lt;= cnt; i++) {            int tmp = 1 + i * d[i - 1];            res = min(res, n - tmp);        }    }    // 输出结果    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n写法 2：vector 存图使用 vector 存储图。虽然略微慢一点，但是很好写。\n// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, a, b;void solve() {    cin &gt;&gt; n;    vector&lt;vector&lt;int&gt;&gt; tree(n);    vector&lt;int&gt; deg(n, 0);    for (int i = 0; i &lt; n - 1; i++) {        cin &gt;&gt; a &gt;&gt; b;        a--, b--;        tree[a].push_back(b);        tree[b].push_back(a);        deg[a]++;        deg[b]++;    }    int res = n;    // 遍历每个节点    for (int v = 0; v &lt; n; v++) {        vector&lt;int&gt; d;        // 获取和 v 相连的点的度数        for (auto to : tree[v])            d.push_back(deg[to]);        // 按照度数降序排列        sort(d.begin(), d.end(), greater&lt;int&gt;());        for (int i = 1; i &lt;= d.size(); i++) {            int num = d[i - 1] * i + 1;            res = min(res, n - num);        }    }    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n\n\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"AtCoder Beginner Contest 386 Summary","url":"/2025/blog/45939/","content":"本文是 AtCoder Beginner Conteset（ABC）386 的总结笔记。\n\n\nA - Full House 2Problem：A - Full House 2\n模拟\n有 ABCD 写着数字的四张牌。问能否添加一张牌，使得五张牌构成：3 张 x 和 2 张 y 的形式。思路非常简单。\n// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int a[4];map&lt;int, int&gt; h;void solve() {    // 读入四个数，同时计数    for (int i = 0; i &lt; 4; i++) {        cin &gt;&gt; a[i];        h[a[i]]++;    }    // 排序一下    sort(a, a + 4);    // 我们只看第一个数和最后一个数即可    // 只能是 22 或者 13 或者 31 的形式，才能构成题目需要的形式    if ((h[a[0]] == 2 &amp;&amp; h[a[3]] == 2) || (h[a[0]] == 3 &amp;&amp; h[a[3]] == 1) ||        (h[a[0]] == 1 &amp;&amp; h[a[3]] == 3))        cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else        cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nB - CalculatorProblem：B - Calculator\n模拟\n这道题目其实很暴力。只需要将所有的 00 转换成一个不相关的字符，最后看一下总长度就知道需要按多少次按键了。\n本答案是将所有的 00 都转化为 1。\n// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;void solve() {    cin &gt;&gt; s;    // 把所有的 00 转化为 1    while (s.find(\"00\") != s.npos)        s.replace(s.find(\"00\"), 2, \"1\");    // 输出答案    cout &lt;&lt; s.size() &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nC - Operate 1Problem：C - Operate 1\n模拟\n题目：有三种操作：\n\n给 S 中添加任意一个字符\n删除 S 中的任意一个字符\n选择 S 中的任意一个字符并转化为另一个字符\n\n请判断执行  次操作中，是否能将 S 转化为 T\n约束条件：字符串最大长度 \n\n思路：本题目是 F 题在 K=1 情况下的特例。\n分成三种情况来讨论：\n\ncase1：S 与 T 长度相同\n\ncase2：S 比 T 长度短 1\n\ncase3：S 比 T 长度长 1\n\n\ncase1 处理方法：\n​\t找到正向和反向的最后一个差异点，如果位置相同，说明只有一个差异点\ncase2 和 case3 处理方法：\n​\t只看长的那个字符串。找到第一个差异点，判断一下去掉这个差异点的字符串s 和 t 是否相同即可。\n// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s, t;int k;void solve() {    // 读入数据    cin &gt;&gt; k &gt;&gt; s &gt;&gt; t;    // 如果 s 和 t 完全相同    if (s == t) {        cout &lt;&lt; \"Yes\" &lt;&lt; endl;        return;    }    // 情况 1：如果长度相同    if (s.size() == t.size()) {        int x, y;        // 从前到后，找到最后一个差异点位置        for (int i = 0; i &lt; s.size(); i++)            if (s[i] != t[i])                x = i;        // 从后往前，找到第一个差异点位置        for (int i = s.size() - 1; i &gt;= 0; i--)            if (s[i] != t[i])                y = i;        // 如果位置相同，说明只有一个点不同        if (x == y)            cout &lt;&lt; \"Yes\" &lt;&lt; endl;        else            cout &lt;&lt; \"No\" &lt;&lt; endl;        return;    }    // 如果长度不同，让 s 是长的那个    if (s.size() &lt; t.size())        swap(s, t);    // 如果长度差异为 1    if (s.size() - t.size() == 1) {        int x;        // 找到第一个差异点        for (int i = 0; i &lt; s.size(); i++)            if (s[i] != t[i]) {                x = i;                break;            }        // 跳过这一个差异点，把前面和后面拼接起来        string tmp = s.substr(0, x) + s.substr(x + 1);        // 如果拼接后的字符串 tmp 和 t 相同，说明只有一个差异点        if (tmp == t)            cout &lt;&lt; \"Yes\" &lt;&lt; endl;        else            cout &lt;&lt; \"No\" &lt;&lt; endl;        return;    }    // 如果能走到这一步，说明长度差异大于 2    cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nD - Diagonal SeparationProblem：D - Diagonal Separation\n贪心\n题目：给定一个  的网格，希望能按照下面条件将格子涂成黑色或白色：\n\n对于每一行： 左边的格子都是黑色，右边的格子都是白色\n对于每一列： 上面的格子都是黑色，下面的格子都是白色\n\n已经给定了  个格子的颜色，请问是否可以将剩余的  个格子涂色，以满足上面条件。\n约束条件：\n\n思路：如果所有的点都是合法的，我们可以很容易的发现单调性：\n​\t从上往下，最左侧的白色格子出现的位置 min_y 一定是逐渐减小的。\n一旦要是有任何一个黑色格子的 y 坐标大于 min_y ，就一定不能满足题目的约束条件。\n// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n, m;struct Node {    int x, y;    char c;} p[N];bool cmp(const Node&amp; a, const Node&amp; b) {    if (a.x == b.x)        return a.y &lt; b.y;    return a.x &lt; b.x;}void solve() {    // 读入数据    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; m; i++)        cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].c;    // 让格子升序排列    sort(p, p + m, cmp);    // min_y 初始化    int min_y = 1e9 + 10;    // 遍历所有的格子    for (int i = 0; i &lt; m; i++) {        // 如果是白色：维护min_y，即白色出现在最左侧的位置        if (p[i].c == 'W')            min_y = min(min_y, p[i].y);        // 如果是黑色格子，并且 y 值超过了 min_y，说明条件不成立        else if (p[i].y &gt;= min_y) {            cout &lt;&lt; \"No\" &lt;&lt; endl;            return;        }    }    cout &lt;&lt; \"Yes\" &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nE - Maximize XORProblem：E - Maximize XOR\nDFS + 优化\n题目：给定一个长度为  的非负整数序列 ，整数 。\n保证组合数  \n从  中选择  个不同的元素，求他们  值的最大值。\n备注：\n：相异为 ，相同为 。例如：\n约束条件：\n\n\n思路：这道题目直接使用 DFS 搜索。但是需要两处前置知识：\n前置知识 1：XOR 的性质XOR 有一些重要的性质：\n\n可逆性：如果 ，那么 ，也就是说再次 XOR 同一个数就相当于把它 “消去”\n自我抵消：任何数字和他本身做 XOR，结果都是0，即 \n恒等性：热河数字 a 和 0 做 XOR，结果不变，即 \n\n从上面的性质，可以推出本题中用到的结论：\n假设长度为 N 的数列 ，取出了前 K 个元素做 XOR 运算。\n等价于先把所有元素做 XOR 运算，再和没有取出的 N-K 个元素做 XOR 运算。\n\n前置知识 2：组合数的性质组合数有一个重要的性质：\n显然，从 n 个物品里面选 m 个组成的方案数，和从 n 个物品中选 n-m 个丢掉的方案数是一致的。\n本题思路：根据上述的两条性质，我们可以对 DFS 进行优化：\n\n如果k的值比较小，我们就搜  即可\n如果 k 的值比较大，我们就搜 ，但是前提要先将所有数组 a 的值进行一遍 XOR 运算。\n\n为什么要使用这个优化方法呢？\n本题中的递归函数 dfs，每调用一次我可以视为  的时间复杂度。当 k 很大的时候，递归函数总的调用次数为  次，尽管  的值可能并不大，但是  的值会非常的大。\n举例：尽管 $C^{98}{100} = 4950 &lt; 10^6，但是中间值C^{50}{100} = 10^{29}$ 非常的巨大，显然超出了限定的时间复杂度。\n所以使用这个优化方法可以极大的减少时间复杂度。\n// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;LL res;LL a[N];int n, k;void dfs(int x, LL sum, int n, int k) {    // 搜到底了    if (k == 0) {        res = max(res, sum);        return;    }    // 超出范围了    if (x == n + 1)        return;    // 选中当前值    dfs(x + 1, sum ^ a[x], n, k - 1);    // 不选当前值    dfs(x + 1, sum, n, k);}void solve() {    cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= n; i++)        cin &gt;&gt; a[i];    LL sum = 0;    // 如果 k 比较大，C(k,n)比较难算，我们就算C(n-k,n)    if (k &gt; n / 2) {        k = n - k;        for (int i = 1; i &lt;= n; i++)            sum ^= a[i];    }    // dfs    dfs(1, sum, n, k);    // 输出结果    cout &lt;&lt; res &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\nF - Operate KProblem：F - Operate K\n最短编辑距离 + 带状 DP\n题目：有三种操作：\n\n给 S 中添加任意一个字符\n删除 S 中的任意一个字符\n选择 S 中的任意一个字符并转化为另一个字符\n\n请判断执行  次操作中，是否能将 S 转化为 T\n约束条件：字符串最大长度 \n\n思路：本题是 C 的加强版。\n直观上，这是一道“最短编辑距离”问题。\n前置知识：“最短编辑距离”问题的标准做法：这类问题有一个标准的 DP 做法如下：\n令  表示字符串  的前  个字符变成  的前  字符所需要的最短编辑距离。\n初始状态 ，那么 i 和 j 的双重循环下，状态迁移公式为：\n\n其中：\n\n ：表示删除 S 的一个字符\n ：表示给 S 插入一个字符（或者说给 T 删去一个字符）\n：表示“替换”或“匹配”。如果 ，则无需替换，；否则 \n\n总时间复杂度为：\n本题的优化思路：带状区域计算 DP如果按照标准做法，那本题的时间复杂度是 ，显然会 TLE。\n但是本题规定了最大操作数不超过 （不超过 20 次操作），这个约束条件就带来了优化空间。\n即：只对“有希望编辑距离不超过 ” 的位置进行 DP 计算。其他位置将会直接认为距离非常大（用 ∞ 表示），从而剪枝掉大量不必要的计算。\n如何做？\n在计算  的时候，如果  的差距很大，意味着  比  短或长很多。如果要将  变得和  完全相同，则操作次数至少要大于 。此时就可以将  超过  的区域直接视为 +∞，不再计算。\n具体做法：\n\n只让  在  的范围内活动\n超出范围的  直接置为 +∞\n\n这样就将原本  的时间复杂度压缩到  \n注意点：习惯上可能直接就把 f 数组声明为  大小。但是本题中  最大为 5e5，此时开出的数组空间为：5e5 * 5e5 * sizeof(int) 大小的内存。对于 int 类型（假设为 4 字节大小），这个数组将会消耗 1e12 byte = 1000GB 的空间，显然是不现实的。如果直接声明这么大的数组，会报 bus error 错误。\n而且我们实际上只使用了中间很小的一部分，绝大多数的空间都是用不上的。所以使用偏置换算的方法即可。\n// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_f#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 5e5 + 10;string S, T;int K;int f[N][60];int get_dp(int i, int j) {    if (abs(i - j) &gt; K)        return 0x3f3f3f3f;    // 偏置    return f[i][j - i + 30];}void solve() {    cin &gt;&gt; K &gt;&gt; S &gt;&gt; T;    int slen = S.size(), tlen = T.size();    S = \" \" + S;    T = \" \" + T;    // f 数组初始化为正无穷    memset(f, 0x3f, sizeof f);    /* 设置初始边界 */    // 对应原来的 f[0][0]：即将空串转化为空串需要 0 步操作    f[0][30] = 0;    // 将空串变成长度为 i 的串，需要 i 步插入操作    for (int i = 1; i &lt;= K; i++)        f[0][30 + i] = i;    // 将长度为 i 的串变成空串，需要 i 步删除操作    for (int i = 1; i &lt;= K; i++)        f[i][30 - i] = i;    /* DP */    // 遍历 S 的每一位    for (int i = 1; i &lt;= slen; i++) {        // 遍历偏置        for (int x = 0; x &lt; 60; x++) {            // 还原出真正的 j            /*                原理：j 只能在[i-30,i+30]范围内，所以下界 j&gt;=i-30                这里加入了偏置 x 去掉了等号                即 j = i - 30 + x            */            int j = i - 30 + x;            // 如果 j 超出了范围            if (j &lt;= 0 || j &gt; tlen)                continue;            int cur_dp = 0x3f3f3f3f;            // S 删除一个字符            cur_dp = min(cur_dp, get_dp(i - 1, j) + 1);            // S 添加一个字符（即，T 删除一个字符）            cur_dp = min(cur_dp, get_dp(i, j - 1) + 1);            int c = 1;            if (S[i] == T[j])                c = 0;            // S 替换一个字符 或者 不操作            cur_dp = min(cur_dp, get_dp(i - 1, j - 1) + c);            // 更新 f            f[i][x] = cur_dp;        }    }    // 输出结果    if (get_dp(slen, tlen) &lt;= K)        cout &lt;&lt; \"Yes\" &lt;&lt; endl;    else        cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n","tags":["Algorithm","Prgoramming Contest","AtCoder","ABC"]},{"title":"C++ string 的常用用法","url":"/2024/blog/57906/","content":"本文是 C++ 中 string 的常用用法的总结笔记。\n\n\n头文件 #include&lt;string&gt;\n1. 初始化 / 赋值string a = \"hello world\";string s = string(10, 't');  // 用10个字符't'初始化string c(10, 't');string d(a.begin(), a.end() - 3);  // a的一部分赋值给dstring e(a.rbegin(), a.rend()); // a的倒序赋值给e\n\n2. 长度与判空a.size() 或者 a.length() 均可获得字符串长度\na.empty() 判断是否为空\na.clear() 把字符串清空\n3. 子串\n使用 string 的构造函数来提取子串\nstring b = string(string a, int start, int num);\n\n截取字符串 str 从 start 起 num 个字符，赋值给子串 substr\n\n使用 substr 函数\nstring b = a.substr(int start, int num);  // 从start开始长度为num的子串提取出来string c = a.substr(2);  // 把a串从2位置开始到末尾的子串提取出来string d = a.substr(2, 4); // 把a串从2位置开始，长度为4的子串提取出来\n\n4. 查找string a = \"abcabxabcc\";cout &lt;&lt; a.find('a') &lt;&lt; endl;  // 查找字符，输出位置cout &lt;&lt; a.find(\"abx\") &lt;&lt; endl;  // 查找字符串，输出找到的起始位置// 判断没有找到字符串：有两种写法，均可if (a.find(\"xx\") == a.npos)    cout &lt;&lt; \"Not Find\" &lt;&lt; endl;if (a.find(\"xx\") == string::npos)    cout &lt;&lt; \"Not Find\" &lt;&lt; endl;\n\n5. 替换，插入与删除string a = \"abcdefg\";/* 替换 */a.replace(2, 3, \"tttt\");  // 从2位置开始，长度为3的部分，替换为tttt。\t// 最后输出结果为 abttttfg/* 插入 */a.insert(2, \"tttt\");  // 从2位置开始，插入tttt\t// 最后输出结果为 abttttcdefga.insert(0, \"tttt\");\t//在开头插入a.insert(a.size(), \"tttt\"); // 在末尾插入/* 删除 */a.erase(2,3);\t\t// 删除 从第0位开始，长度为3的字符串。结果为 abfga.erase(0,2);  // 删除前两个元素。结果为 cdefga.erase(3);    // 删除位置3以后的所有字符。结果为 abc\n\n6. 遍历三种常用的遍历方式：\nstring a = \"abcdefg\";// 方法 1：for (int i = 0; i &lt; a.size(); i++)    cout &lt;&lt; a[i] &lt;&lt; endl;// 方法 2：for (char c : a)    cout &lt;&lt; c &lt;&lt; endl;// 方法 3：迭代器for (string::iterator it = a.begin(); it != a.end(); ++it)    cout &lt;&lt; *it &lt;&lt; endl;\n\n7. 数值与字符串相互转换int b = stoi(\"121\");      // 字符串转为intfloat c = stof(\"12.345\");  // 字符串转为floatstring d = to_string(121);     // int转为字符串string e = to_string(12.345);  // float转为字符串\n\n8. 排序string a = \"Aa32Cc1bB\";// 升序排列：数字1-9 -&gt; 大写字母A-Z -&gt; 小写字母a-z （实际就是按照 ACSII 码从小到大排序）sort(a.begin(), a.end());cout &lt;&lt; a &lt;&lt; endl;    // 结果为：123ABCabc// 降序排列：小写字母z-a -&gt; 大写字母Z-A -&gt; 数字9-1sort(a.begin(), a.end(), greater&lt;char&gt;());cout &lt;&lt; a &lt;&lt; endl;    // 结果为：cbaCBA321\n\n9. 杂项string a = \"test\";// 末尾插入一个字符（注意，这里只能是字符）a.push_back('2');// 弹出最后一个字符a.pop_back();\n","tags":["C++","STL"]},{"title":"质数的基础知识","url":"/2023/blog/59545/","content":"在大于 1 的整数中，如果只能被 1 和本身整除，就被称为质数，或素数。\n1. 质数的判定——试除法方法 1是最笨的方法，复杂度为 。因为没有经过优化，不建议使用。\nbool is_prime(int n){    // 如果 n &lt; 2 则肯定不为质数    if( n &lt; 2 ) return false;    for(int i = 2 ; i &lt; n ; i++){        // 任何一个数 i 能整除 n，说明 n 不是质数        if( n % i == 0) return false;    }    return true;}\n\n方法 2：优化后性质：如果  能整除  ， 那么  也能整除 。（即  的约数都是成对出现的，例如，2 能整除 12，6 也能整除 12 ）。\n所以我们可以只枚举一对中较小的那一个。那么只需要枚举验证 ， 之间的数即可。复杂度为 。\nAcWing 866: 试除法判定质数问题链接：https://www.acwing.com/problem/content/868/\n题目：\n给定 n 个正整数  ，判定每个数是否是质数。\n数据范围：\n\n\n解题思路：\n// Problem: https://www.acwing.com/problem/content/868/// 质数判定#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, x;bool is_prime(int n) {    if (n &lt; 2)        return false;    for (int i = 2; i &lt;= n / i; i++) {        if (n % i == 0)            return false;    }    return true;}void solve() {    cin &gt;&gt; n;    while (n--) {        cin &gt;&gt; x;        if (is_prime(x))            cout &lt;&lt; \"Yes\" &lt;&lt; endl;        else            cout &lt;&lt; \"No\" &lt;&lt; endl;    }}int main() {    cin.tie(0);    ios_base::sync_with_stdio(false);    solve();    return 0;}\n\n注意：判断条件处最佳写法为： i &lt;= n / i 。\n不推荐写成 i &lt;= sqrt(n) 因为每次都会计算一次 sqrt，非常的慢，影响执行速度；\n不推荐写成 i * i &lt;= n 因为当 i 非常大，逼近 int 的上限 2147483647 时，容易导致 i*i 的结果溢出变为一个负数，此时的程序时不稳定的。\n2. 分解质因数——试除法质因数：是指能够整除给定正整数的质数。\n\n1 没有质因子。\n5 只有 1 个质因子，5 本身。（5 是质数）\n6 的质因子是 2 和 3。(6 = 2 × 3)\n2、4、8、16 等只有 1 个质因子：2。（2 是质数，4 =2²，8 = 2³，如此类推）\n10 有 2 个质因子：2 和 5。(10 = 2 × 5)\n\n从小到大尝试 n 的所有的因数。 只需要枚举到 sqrt(n) 即可（因为 n 中最多只包含一个大于 n 的质因数）\n时间复杂度最慢是 \nAcWing 867: 分解质因数问题链接：https://www.acwing.com/problem/content/869/\n题目：\n给定个正整数  ，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。\n数据范围：\n\n\n解题思路：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void divide(int x){    for (int i = 2; i &lt;= x / i; i ++ )        if (x % i == 0)        {            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;        }    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl;    cout &lt;&lt; endl;}int main(){    int count;    cin &gt;&gt; count;    while(count--){        int n;        cin &gt;&gt; n;        divide(n);    }    return 0;}\n\n3. 质数筛选参考：质数其实没有那么多。100 万以内，大概有 8 万个质数。\n方法 1：这种筛选方法的时间复杂度为：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;int primes[N] , cnt ;bool st[N];void get_primes(int n){    for(int i = 2 ; i &lt;= n ; i++ ){        // 如果这个数已经被筛过了，那么留下的数是一个质数，直接就存到 primes 数组中        if(!st[i]){\t\t\t\t\t\t// 把这个质数存进 primes 数组中            primes[ cnt ++ ] = i ;        }        // j 从 2i 开始循环，查看i的倍数，给它赋值为true，标记他不是一个质数        for(int j = i + i ; j &lt;= n ; j += i) st[j] = true;    }}int main(){    int n;    cin &gt;&gt; n ;    get_primes(n);    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;}\n\n方法 2：埃氏筛法质数定理：1 ～ n 中，有 个质数。\n这个方法中的时间复杂度约为  ，基本上和 O(n) 复杂度是一个级别的。\n这个算法也称为 埃氏筛法。\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;int primes[N] , cnt ;bool st[N];void get_primes(int n){    for(int i = 2 ; i &lt;= n ; i++ ){        // 确认了这个数是一个质数了        if(!st[i]){\t\t\t\t\t\t// 把这个质数存进 primes 数组中            primes[cnt++] = i;            // 只需要把质数的倍数筛掉，就可以了            for(int j = i+i ; j &lt;= n ; j += i) st[j] = true;        }    }}int main(){    int n;    cin &gt;&gt; n;    get_primes(n);    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;}\n\n方法 3：线性筛法n 只会被最小质因子筛掉\n每一个数只会被最小质因子筛一次，所以是线性的。\n注：下面两个代码的 primes 数组声明方式不一样。一个用普通数组，一个用 vector。供参考\n// 注释版本#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;int primes[N] , cnt ;bool st[N];void get_primes(int n){    for(int i = 2 ; i &lt;= n ; i++ ){        // 如果这个数没被筛掉，那么这个数为质数        if(!st[i]) primes[cnt ++] = i;        // 从小到大枚举所有的质数        for(int j = 0 ; primes[j] &lt;= n / i ; j ++){            // 把当前质数和i的乘积筛掉            st[ primes[j] * i] = true;      // 只用最小质因子来筛选            if( i % primes[j] == 0) break;  // 当这句话发生的时候，说明primes[j]一定是i的最小质因子            // 1. i % primes[j] == 0，此时，primes[j]一定是i的最小质因子，即 primes[j] 一定是 primes[j] * i 的最小质因子            // 2. i % primes[j] != 0，primes[j] 一定小于i的所有质因子，即 primes[j] 一定是 primes[j] * i 的最小质因子        }    }}int main(){    int n;    cin &gt;&gt; n;    get_primes(n);    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;}\n\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 1000010;int cnt;bool st[N];vector&lt;int&gt; primes;void get_primes(int n) {    for (int i = 2; i &lt;= n; i++) {        if (!st[i])            primes.push_back(i);        for (int j = 0; primes[j] &lt;= n / i; j++) {            st[primes[j] * i] = true;            if (i % primes[j] == 0)                break;        }    }}int main() {    int n;    cin &gt;&gt; n;    get_primes(n);    cout &lt;&lt; primes.size() &lt;&lt; endl;}\n","tags":["Algorithm","Math"]}]