{"meta":{"title":"JoeyDDong's Blog","subtitle":"一个程序员的个人博客","description":"","author":"JoeyDDong","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2024-11-30T04:41:00.000Z","updated":"2024-12-15T13:46:12.565Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"中文English日本語 @media (max-width: 991px) { .responsive-container { flex-direction: column !important; align-items: center !important; width: 100% !important; } .profile-image { width: 300px !important; } } 你好呀！ 我是 JoeyDDong。 关于我你好，见字如面！我是 JoeyDDong。目前在京都大学情报学研究科攻读硕士学位。从中国来到这座千年古都，每一天都在现代科技与传统文化交织的环境中探索成长。 生活对我而言就是一场充满可能的冒险。作为一个热衷于算法竞赛的程序员，我享受在代码中探索逻辑之美；闲暇时光里，常常拿起相机捕捉生活的精彩瞬间，也喜欢用文字记录对世界的思考。 无论前方有多少未知和挑战，我都会微笑着大步向前——因为我深信，每个困难都是成长的礼物。 “终身学习”是我给自己的定位——在这个日新月异的时代，保持开放和好奇的心态，勇敢地拥抱每一个未知，感受探索带来的快乐。生命因为未知而美丽，而我愿意成为那个永远充满勇气和热情的探索者。 专业哈尔滨工业大学 - 本科 - 机电工程学院 - 机械设计制造及其自动化 京都大学 - 硕士 - 信息学院 - 系统科学 兴趣爱好 算法竞赛：目前主要在 AtCoder 和 AcWing 两个平台学习算法知识。 摄影：作为一名业余摄影师，拍了很多的手机壁纸图片。 联系我：GitHub：weiweiweidong @media (max-width: 991px) { .responsive-container { flex-direction: column !important; align-items: center !important; width: 100% !important; } .profile-image { width: 300px !important; } } Hello! I'm JoeyDDong. About MeHello! I’m JoeyDDong. I’m currently pursuing a Master’s degree at the Graduate School of Informatics, Kyoto University. Coming from China to this millennial capital, I grow and explore daily in an environment where modern technology intertwines with traditional culture. Life, to me, is an adventure full of possibilities. As a programmer passionate about algorithmic competitions, I enjoy exploring the beauty of logic in code. In my leisure time, I often capture life’s wonderful moments through photography and like to record my thoughts about the world through writing. No matter how many unknowns and challenges lie ahead, I will stride forward with a smile—because I firmly believe that every difficulty is a gift for growth. “Lifelong learning” is my self-positioning—in this rapidly changing era, maintaining an open and curious mindset, bravely embracing every unknown, and experiencing the joy of exploration. Life is beautiful because of the unknown, and I want to be that explorer who is forever full of courage and passion. Education and Academic BackgroundHarbin Institute of Technology (Bachelor’s) - Mechanical Design, Manufacturing and Automation Kyoto University (Master’s) - Graduate School of Informatics - Systems Science Interests Competitive Programming: Currently learning algorithms mainly on AtCoder and AcWing platforms. Photography: As an amateur photographer, I’ve taken many phone wallpaper photos. Contact Me:GitHub：weiweiweidong @media (max-width: 991px) { .responsive-container { flex-direction: column !important; align-items: center !important; width: 100% !important; } .profile-image { width: 300px !important; } } こんにちは！ JoeyDDong です。 自己紹介はじめまして！JoeyDDongと申します。現在、京都大学情報学研究科で修士課程に在籍しています。中国からこの千年の都に来て、最新技術と伝統文化が織り成す環境の中で日々成長し、探求しています。 人生は私にとって可能性に満ちた冒険です。アルゴリズムコンテストに情熱を注ぐプログラマーとして、コードの中に論理の美しさを探求することを楽しんでいます。余暇には、カメラを手に生活の素晴らしい瞬間を捉え、文章を通して世界への思考を記録することも好きです。 どれだけ多くの未知や課題が待ち受けていても、笑顔で前進していきます。なぜなら、すべての困難は成長への贈り物だと信じているからです。 「生涯学習」は私の自己定位です：この急速に変化する時代において、開放的で好奇心旺盛な姿勢を保ち、すべての未知に勇気を持って挑み、探求がもたらす喜びを感じています。人生は未知があるからこそ美しく、私は永遠に勇気と情熱に満ちた探求者でありたいと思います。 学歴ハルビン工業大学（学士）- 機電工程学院 - 機械設計製造及びその自動化専攻 京都大学（修士）- 情報学研究科 - システム科学専攻 趣味 競技プログラミング：現在、主に AtCoder と AcWing のプラットフォームでアルゴリズムを学習しています。 写真撮影：アマチュアカメラマンとして、多くのスマートフォン用壁紙写真を撮影しています。 連絡先：GitHub：weiweiweidong"},{"title":"tags","date":"2024-11-30T04:40:47.000Z","updated":"2024-11-30T04:40:47.257Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"tools","date":"2024-11-30T04:41:04.000Z","updated":"2024-12-11T06:38:51.471Z","comments":true,"path":"tools/index.html","permalink":"http://example.com/tools/index.html","excerpt":"","text":""},{"title":"photos","date":"2024-11-30T04:40:54.000Z","updated":"2024-12-13T07:07:04.567Z","comments":true,"path":"photos/index.html","permalink":"http://example.com/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"AtCoder Beginner Contest 386 Summary","slug":"AtCoder_386_Summary","date":"2025-01-02T00:09:33.000Z","updated":"2025-01-04T11:57:52.300Z","comments":true,"path":"2025/blog/45939/","permalink":"http://example.com/2025/blog/45939/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）386 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）386 的总结笔记。 A - Full House 2Problem：A - Full House 2 模拟 有 ABCD 写着数字的四张牌。问能否添加一张牌，使得五张牌构成：3 张 x 和 2 张 y 的形式。思路非常简单。 1234567891011121314151617181920212223242526272829303132333435// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int a[4];map&lt;int, int&gt; h;void solve() { // 读入四个数，同时计数 for (int i = 0; i &lt; 4; i++) { cin &gt;&gt; a[i]; h[a[i]]++; } // 排序一下 sort(a, a + 4); // 我们只看第一个数和最后一个数即可 // 只能是 22 或者 13 或者 31 的形式，才能构成题目需要的形式 if ((h[a[0]] == 2 &amp;&amp; h[a[3]] == 2) || (h[a[0]] == 3 &amp;&amp; h[a[3]] == 1) || (h[a[0]] == 1 &amp;&amp; h[a[3]] == 3)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - CalculatorProblem：B - Calculator 模拟 这道题目其实很暴力。只需要将所有的 00 转换成一个不相关的字符，最后看一下总长度就知道需要按多少次按键了。 本答案是将所有的 00 都转化为 1。 1234567891011121314151617181920212223242526// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;void solve() { cin &gt;&gt; s; // 把所有的 00 转化为 1 while (s.find(\"00\") != s.npos) s.replace(s.find(\"00\"), 2, \"1\"); // 输出答案 cout &lt;&lt; s.size() &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Operate 1Problem：C - Operate 1 模拟 题目：有三种操作： 给 S 中添加任意一个字符 删除 S 中的任意一个字符 选择 S 中的任意一个字符并转化为另一个字符 请判断执行 次操作中，是否能将 S 转化为 T 约束条件：字符串最大长度 思路：本题目是 F 题在 K=1 情况下的特例。 分成三种情况来讨论： case1：S 与 T 长度相同 case2：S 比 T 长度短 1 case3：S 比 T 长度长 1 case1 处理方法： ​ 找到正向和反向的最后一个差异点，如果位置相同，说明只有一个差异点 case2 和 case3 处理方法： ​ 只看长的那个字符串。找到第一个差异点，判断一下去掉这个差异点的字符串s 和 t 是否相同即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s, t;int k;void solve() { // 读入数据 cin &gt;&gt; k &gt;&gt; s &gt;&gt; t; // 如果 s 和 t 完全相同 if (s == t) { cout &lt;&lt; \"Yes\" &lt;&lt; endl; return; } // 情况 1：如果长度相同 if (s.size() == t.size()) { int x, y; // 从前到后，找到最后一个差异点位置 for (int i = 0; i &lt; s.size(); i++) if (s[i] != t[i]) x = i; // 从后往前，找到第一个差异点位置 for (int i = s.size() - 1; i &gt;= 0; i--) if (s[i] != t[i]) y = i; // 如果位置相同，说明只有一个点不同 if (x == y) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; return; } // 如果长度不同，让 s 是长的那个 if (s.size() &lt; t.size()) swap(s, t); // 如果长度差异为 1 if (s.size() - t.size() == 1) { int x; // 找到第一个差异点 for (int i = 0; i &lt; s.size(); i++) if (s[i] != t[i]) { x = i; break; } // 跳过这一个差异点，把前面和后面拼接起来 string tmp = s.substr(0, x) + s.substr(x + 1); // 如果拼接后的字符串 tmp 和 t 相同，说明只有一个差异点 if (tmp == t) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; return; } // 如果能走到这一步，说明长度差异大于 2 cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - Diagonal SeparationProblem：D - Diagonal Separation 贪心 题目：给定一个 的网格，希望能按照下面条件将格子涂成黑色或白色： 对于每一行： 左边的格子都是黑色，右边的格子都是白色 对于每一列： 上面的格子都是黑色，下面的格子都是白色 已经给定了 个格子的颜色，请问是否可以将剩余的 个格子涂色，以满足上面条件。 约束条件： 思路：如果所有的点都是合法的，我们可以很容易的发现单调性： ​ 从上往下，最左侧的白色格子出现的位置 min_y 一定是逐渐减小的。 一旦要是有任何一个黑色格子的 y 坐标大于 min_y ，就一定不能满足题目的约束条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n, m;struct Node { int x, y; char c;} p[N];bool cmp(const Node&amp; a, const Node&amp; b) { if (a.x == b.x) return a.y &lt; b.y; return a.x &lt; b.x;}void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; p[i].c; // 让格子升序排列 sort(p, p + m, cmp); // min_y 初始化 int min_y = 1e9 + 10; // 遍历所有的格子 for (int i = 0; i &lt; m; i++) { // 如果是白色：维护min_y，即白色出现在最左侧的位置 if (p[i].c == 'W') min_y = min(min_y, p[i].y); // 如果是黑色格子，并且 y 值超过了 min_y，说明条件不成立 else if (p[i].y &gt;= min_y) { cout &lt;&lt; \"No\" &lt;&lt; endl; return; } } cout &lt;&lt; \"Yes\" &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Maximize XORProblem：E - Maximize XOR DFS + 优化 题目：给定一个长度为 的非负整数序列 ，整数 。 保证组合数 从 中选择 个不同的元素，求他们 值的最大值。 备注： ：相异为 ，相同为 。例如： 约束条件： 思路：这道题目直接使用 DFS 搜索。但是需要两处前置知识： 前置知识 1：XOR 的性质XOR 有一些重要的性质： 可逆性：如果 ，那么 ，也就是说再次 XOR 同一个数就相当于把它 “消去” 自我抵消：任何数字和他本身做 XOR，结果都是0，即 恒等性：热河数字 a 和 0 做 XOR，结果不变，即 从上面的性质，可以推出本题中用到的结论： 假设长度为 N 的数列 ，取出了前 K 个元素做 XOR 运算。 等价于先把所有元素做 XOR 运算，再和没有取出的 N-K 个元素做 XOR 运算。 前置知识 2：组合数的性质组合数有一个重要的性质： 显然，从 n 个物品里面选 m 个组成的方案数，和从 n 个物品中选 n-m 个丢掉的方案数是一致的。 本题思路：根据上述的两条性质，我们可以对 DFS 进行优化： 如果k的值比较小，我们就搜 即可 如果 k 的值比较大，我们就搜 ，但是前提要先将所有数组 a 的值进行一遍 XOR 运算。 为什么要使用这个优化方法呢？ 本题中的递归函数 dfs，每调用一次我可以视为 的时间复杂度。当 k 很大的时候，递归函数总的调用次数为 次，尽管 的值可能并不大，但是 的值会非常的大。 举例：尽管 $C^{98}{100} = 4950 &lt; 10^6，但是中间值C^{50}{100} = 10^{29}$ 非常的巨大，显然超出了限定的时间复杂度。 所以使用这个优化方法可以极大的减少时间复杂度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;LL res;LL a[N];int n, k;void dfs(int x, LL sum, int n, int k) { // 搜到底了 if (k == 0) { res = max(res, sum); return; } // 超出范围了 if (x == n + 1) return; // 选中当前值 dfs(x + 1, sum ^ a[x], n, k - 1); // 不选当前值 dfs(x + 1, sum, n, k);}void solve() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; LL sum = 0; // 如果 k 比较大，C(k,n)比较难算，我们就算C(n-k,n) if (k &gt; n / 2) { k = n - k; for (int i = 1; i &lt;= n; i++) sum ^= a[i]; } // dfs dfs(1, sum, n, k); // 输出结果 cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} F - Operate KProblem：F - Operate K 最短编辑距离 + 带状 DP 题目：有三种操作： 给 S 中添加任意一个字符 删除 S 中的任意一个字符 选择 S 中的任意一个字符并转化为另一个字符 请判断执行 次操作中，是否能将 S 转化为 T 约束条件：字符串最大长度 思路：本题是 C 的加强版。 直观上，这是一道“最短编辑距离”问题。 前置知识：“最短编辑距离”问题的标准做法：这类问题有一个标准的 DP 做法如下： 令 表示字符串 的前 个字符变成 的前 字符所需要的最短编辑距离。 初始状态 ，那么 i 和 j 的双重循环下，状态迁移公式为： 其中： ：表示删除 S 的一个字符 ：表示给 S 插入一个字符（或者说给 T 删去一个字符） ：表示“替换”或“匹配”。如果 ，则无需替换，；否则 总时间复杂度为： 本题的优化思路：带状区域计算 DP如果按照标准做法，那本题的时间复杂度是 ，显然会 TLE。 但是本题规定了最大操作数不超过 （不超过 20 次操作），这个约束条件就带来了优化空间。 即：只对“有希望编辑距离不超过 ” 的位置进行 DP 计算。其他位置将会直接认为距离非常大（用 ∞ 表示），从而剪枝掉大量不必要的计算。 如何做？ 在计算 的时候，如果 的差距很大，意味着 比 短或长很多。如果要将 变得和 完全相同，则操作次数至少要大于 。此时就可以将 超过 的区域直接视为 +∞，不再计算。 具体做法： 只让 在 的范围内活动 超出范围的 直接置为 +∞ 这样就将原本 的时间复杂度压缩到 注意点：习惯上可能直接就把 f 数组声明为 大小。但是本题中 最大为 5e5，此时开出的数组空间为：5e5 * 5e5 * sizeof(int) 大小的内存。对于 int 类型（假设为 4 字节大小），这个数组将会消耗 1e12 byte = 1000GB 的空间，显然是不现实的。如果直接声明这么大的数组，会报 bus error 错误。 而且我们实际上只使用了中间很小的一部分，绝大多数的空间都是用不上的。所以使用偏置换算的方法即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Problem: https://atcoder.jp/contests/abc386/tasks/abc386_f#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 5e5 + 10;string S, T;int K;int f[N][60];int get_dp(int i, int j) { if (abs(i - j) &gt; K) return 0x3f3f3f3f; // 偏置 return f[i][j - i + 30];}void solve() { cin &gt;&gt; K &gt;&gt; S &gt;&gt; T; int slen = S.size(), tlen = T.size(); S = \" \" + S; T = \" \" + T; // f 数组初始化为正无穷 memset(f, 0x3f, sizeof f); /* 设置初始边界 */ // 对应原来的 f[0][0]：即将空串转化为空串需要 0 步操作 f[0][30] = 0; // 将空串变成长度为 i 的串，需要 i 步插入操作 for (int i = 1; i &lt;= K; i++) f[0][30 + i] = i; // 将长度为 i 的串变成空串，需要 i 步删除操作 for (int i = 1; i &lt;= K; i++) f[i][30 - i] = i; /* DP */ // 遍历 S 的每一位 for (int i = 1; i &lt;= slen; i++) { // 遍历偏置 for (int x = 0; x &lt; 60; x++) { // 还原出真正的 j /* 原理：j 只能在[i-30,i+30]范围内，所以下界 j&gt;=i-30 这里加入了偏置 x 去掉了等号 即 j = i - 30 + x */ int j = i - 30 + x; // 如果 j 超出了范围 if (j &lt;= 0 || j &gt; tlen) continue; int cur_dp = 0x3f3f3f3f; // S 删除一个字符 cur_dp = min(cur_dp, get_dp(i - 1, j) + 1); // S 添加一个字符（即，T 删除一个字符） cur_dp = min(cur_dp, get_dp(i, j - 1) + 1); int c = 1; if (S[i] == T[j]) c = 0; // S 替换一个字符 或者 不操作 cur_dp = min(cur_dp, get_dp(i - 1, j - 1) + c); // 更新 f f[i][x] = cur_dp; } } // 输出结果 if (get_dp(slen, tlen) &lt;= K) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 385 Summary","slug":"AtCoder_385_Summary","date":"2024-12-25T04:22:11.000Z","updated":"2025-01-04T11:57:52.302Z","comments":true,"path":"2024/blog/17255/","permalink":"http://example.com/2024/blog/17255/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）385 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）385 的总结笔记。 A - EquallyProblem：A - Equally 有两种思路。 分成四种情况来讨论 只要 abc 的总和能被 abc 中的最大值整除，就意味着能被分开。（很巧妙） 123456789101112131415161718192021222324252627282930313233343536// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int a, b, c;// 解法 1：分成四种情况来讨论void solve1() { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a + b == c || a + c == b || b + c == a || (a == b &amp;&amp; b == c)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}// 解法 2：只要 sum 能被 abc 中的最大值整除即可void solve2() { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int mx = max({a, b, c}); int sum = a + b + c; if (sum % mx == 0) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve1(); // solve2(); return 0;} B - Santa Claus 1Problem：B - Santa Claus 1 模拟题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 110;char g[N][N];int h, w, x, y;string s;bool st[N][N];int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};int res;// 转换函数：把 UDLR 转换为 idxint trans(char c) { if (c == 'U') return 0; else if (c == 'D') return 1; else if (c == 'L') return 2; else return 3;}void solve() { // 读入数据 cin &gt;&gt; h &gt;&gt; w &gt;&gt; x &gt;&gt; y; for (int i = 0; i &lt; h; i++) for (int j = 0; j &lt; w; j++) cin &gt;&gt; g[i][j]; cin &gt;&gt; s; // 1-base 转换为 0-base x--, y--; // 遍历每个指令 for (auto c : s) { int d = trans(c); // 计算下一个点的坐标 int a = x + dx[d], b = y + dy[d]; // 越界 if (a &lt; 0 || a &gt;= h || b &lt; 0 || b &gt;= w) continue; // 撞墙 if (g[a][b] == '#') continue; // 如果是第一次遇见'@'，计数+1 if (g[a][b] == '@' &amp;&amp; !st[a][b]) { st[a][b] = true; res++; } // 更新坐标 x = a, y = b; } // 输出结果 cout &lt;&lt; x + 1 &lt;&lt; \" \" &lt;&lt; y + 1 &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Illuminate BuildingsProblem：C - Illuminate Buildings DP 题目：N 栋建筑排成一列。高度为 H_i 想要给建筑点灯，有下面要求： 选中的建筑物要有相同的高度 选中建筑物之间间隔相同 求能选出的最多建筑。 约束条件： 思路：DP 的最长子序列问题。 令 f[i][j] 表示：以第 i 个位置结尾，且前后两个相同数字的距离是 j 时，最大长度。 时间复杂度为 ，本题中为 的时间复杂度。 1234567891011121314151617181920212223242526272829303132333435363738394041// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_c// DP#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 3010;int a[N];int f[N][N];int n, res;void solve() { // 读入数据 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; // dp 数组初始化 for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= n; j++) f[i][j] = 1; // f[i][j] 表示：以第i个位置结尾，且前后两个相同数字距离是j时，最大长度 for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) { if (i - j &gt;= 1 &amp;&amp; a[i] == a[i - j]) f[i][j] = max(f[i][j], f[i - j][j] + 1); res = max(res, f[i][j]); } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - Santa Claus 2Problem：D - Santa Claus 2 STL + 二分 题目：二维平面上有坐标为 共 个房子。 最开始，圣诞老人在起点 处，按照序列 方式移动 若 是当前点坐标 若 是 U，则沿着直线从 移动到 若 是 D，则沿着直线从 移动到 若 是 L，则沿着直线从 移动到 若 是 R，则沿着直线从 移动到 求出完成所有移动后，圣诞老人经过的房子的数量。（若多次经过相同房间，只计算 1 次） 约束条件： There is no house at . 思路：有两个核心问题： 如何快速知道一次移动中会经过多少个房子 如何筛选掉已经走过的房子 容易发现，每次的移动都是直上直下或者水平的移动，也就是说在移动的时候，其中一个坐标轴的坐标是固定的。 解决方法： 维护一个特殊的数据结构：map&lt;int , set&lt;int&gt;&gt;，再使用二分。 举例：对于数据结构 map&lt;int , set&lt;int&gt;&gt; mx 来说，key 存储的是每个房子的 x 坐标，value 存的是相同 x 坐标的所有 y 坐标的值。那么在一次移动中，一定会对应左右端点。那么使用二分在 set 中查找左右端点，中间的值就是经过的点。将这几个点从 set 中清除掉，就实现了只计算一次经过的功能。 时间复杂度为 ，对应的是 m 次移动，每次移动中会进行两次二分查找。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;using Map = map&lt;int, set&lt;int&gt;&gt;;Map mx, my;vector&lt;int&gt; temp;int n, m; // 点的数量，移动次数LL x, y; // 起始坐标LL res;char d; // 临时变量，记录移动方向LL c; // 临时变量，记录移动距离//void run(LL x, LL y, LL u, LL v, Map&amp; i, Map&amp; j) { // 判断点的位置是否合法 if (i[x].empty()) return; if (abs(x) &gt; 1e9 || abs(y) &gt; 1e9) return; temp.clear(); auto bg = i[x].lower_bound(y + u); auto ed = i[x].upper_bound(y + v); // 从 bg 到 ed 之间所有的元素都要删除并计数 for (auto it = bg; it != ed; it++) { res++; temp.push_back((*it)); } // 在原始数组中删除经过的点 for (auto p : temp) { i[x].erase(p); j[p].erase(x); }}void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y; for (int i = 1, u, v; i &lt;= n; i++) { cin &gt;&gt; u &gt;&gt; v; mx[u].insert(v); // x 下有多少个 y my[v].insert(u); // y 下有多少个 x } // 处理所有移动 for (int i = 1; i &lt;= m; i++) { char d; cin &gt;&gt; d &gt;&gt; c; // 读入移动方向和距离 if (d == 'U') run(x, y, 0, c, mx, my), y += c; if (d == 'D') run(x, y, -c, 0, mx, my), y -= c; if (d == 'L') run(y, x, -c, 0, my, mx), x -= c; if (d == 'R') run(y, x, 0, c, my, mx), x += c; } cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Snowflake TreeProblem：E - Snowflake Tree 贪心 题目：定义“雪花树”： 整数 x 与 y 选中一个中心点 中心点向外连接 x 个节点，作为中间层 中间层的每个节点，各向外连接 y 个节点，作为最外层 例如：x=4，y=2 的情况为： 给定一个1~N 共 N 个节点的树 T，有 N-1 条边。 若删除部分节点能让这棵树变成“雪花树”，输出最少删除多少个节点。 约束条件： 思路：我们很容易发现，对于一棵 的 “雪花树”，它所含有的节点数肯定为 ，表示的含义是：中心有 1 个节点，周围有 x 个节点，最外侧有 个节点。 也就意味着，对于 N 个节点的树，如果能确定下来“雪花树”的尺寸为 ，那么被删掉的节点数就是 。 问题就转化为了：对于一个中心点，如何求出它的 “雪花树”？使用贪心的思想。 使用下图举例： 我们假设有上面的这棵树。确定中心点 M 后，我们就可以知道中心点周围有多少个点。根据度数，实际就可以知道再向外最多扩展多少个点。 刚好就是扩展点的度数。 我们将所有的点按照度数大小降序排列。将会依次遍历 EACBD 几个点。 先看 E 点：E 点向外最多扩展 6 个节点，意味着此时生成的 “雪花树” 大小为 再看 A 点：A 点向外最多扩展 5 个节点，意味着此时生成的 “雪花树” 大小为 再看 C 点：C 点向外最多扩展 4 个节点，意味着此时生成的 “雪花树” 大小为 ​ …… 通过遍历，我们实际就可以知道能够生成的最大的 “雪花树” 的尺寸了，相应的，也就知道最少删除多少节点，就能生成该 “雪花树” 了。 时间复杂度为 。最大的瓶颈是排序部分。 写法 1：数组存图使用数组来存储图（这个写法稍微麻烦一点，但是比 vector 快） 注意：这里会遇到一个坑： ​ 如果使用 memset 重置 d 数组，有 的时间复杂度，会导致程序 TLE。但实际上用 cnt 维护 d 的长度，不用重置 d 数组也没有关系。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 3e5 + 10, M = 6e5 + 10;int h[N], e[M], ne[M], idx; // 存储图int deg[N]; // 存储所有节点的度数int d[N], cnt; // 存储中心点周围点的度数int n;// 加边void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx; idx++;}void solve() { // h 数组初始化 memset(h, -1, sizeof h); // 读入边数据，建边，同时计算各个点的度数 cin &gt;&gt; n; for (int i = 0, a, b; i &lt; n - 1; i++) { cin &gt;&gt; a &gt;&gt; b; add(a, b), add(b, a); deg[a]++, deg[b]++; } int res = n; // 遍历每个点作为中心点 for (int now = 1; now &lt;= n; now++) { /* 注意：这里有个坑。照理说 d 数组每次都应该清空再用。 但是 memset d 重置为 0 要 O(N) 的时间复杂度。 这里重置 d 的话，就会超时，程序 TLE 实际上使用 cnt 来维护 d 的长度，不用重置也可以。 */ // memset(d, 0, sizeof d); cnt = 0; for (int j = h[now]; j != -1; j = ne[j]) { int next = e[j]; // 获取 now 周围的点 d[cnt++] = deg[next]; // 记录点的度数 } sort(d, d + cnt, greater&lt;int&gt;()); // 降序排列 // 分别计算“雪花树”的尺寸，更新最少删除点的值 for (int i = 1; i &lt;= cnt; i++) { int tmp = 1 + i * d[i - 1]; res = min(res, n - tmp); } } // 输出结果 cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} 写法 2：vector 存图使用 vector 存储图。虽然略微慢一点，但是很好写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Problem: https://atcoder.jp/contests/abc385/tasks/abc385_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, a, b;void solve() { cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; tree(n); vector&lt;int&gt; deg(n, 0); for (int i = 0; i &lt; n - 1; i++) { cin &gt;&gt; a &gt;&gt; b; a--, b--; tree[a].push_back(b); tree[b].push_back(a); deg[a]++; deg[b]++; } int res = n; // 遍历每个节点 for (int v = 0; v &lt; n; v++) { vector&lt;int&gt; d; // 获取和 v 相连的点的度数 for (auto to : tree[v]) d.push_back(deg[to]); // 按照度数降序排列 sort(d.begin(), d.end(), greater&lt;int&gt;()); for (int i = 1; i &lt;= d.size(); i++) { int num = d[i - 1] * i + 1; res = min(res, n - num); } } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"C++ string 的常用用法","slug":"CPP_string_的常用用法","date":"2024-12-19T13:41:55.000Z","updated":"2025-01-04T11:57:52.301Z","comments":true,"path":"2024/blog/57906/","permalink":"http://example.com/2024/blog/57906/","excerpt":"本文是 C++ 中 string 的常用用法的总结笔记。","text":"本文是 C++ 中 string 的常用用法的总结笔记。 头文件 #include&lt;string&gt; 1. 初始化 / 赋值12345string a = \"hello world\";string s = string(10, 't'); // 用10个字符't'初始化string c(10, 't');string d(a.begin(), a.end() - 3); // a的一部分赋值给dstring e(a.rbegin(), a.rend()); // a的倒序赋值给e 2. 长度与判空a.size() 或者 a.length() 均可获得字符串长度 a.empty() 判断是否为空 a.clear() 把字符串清空 3. 子串 使用 string 的构造函数来提取子串 1string b = string(string a, int start, int num); 截取字符串 str 从 start 起 num 个字符，赋值给子串 substr 使用 substr 函数 123string b = a.substr(int start, int num); // 从start开始长度为num的子串提取出来string c = a.substr(2); // 把a串从2位置开始到末尾的子串提取出来string d = a.substr(2, 4); // 把a串从2位置开始，长度为4的子串提取出来 4. 查找12345678910string a = \"abcabxabcc\";cout &lt;&lt; a.find('a') &lt;&lt; endl; // 查找字符，输出位置cout &lt;&lt; a.find(\"abx\") &lt;&lt; endl; // 查找字符串，输出找到的起始位置// 判断没有找到字符串：有两种写法，均可if (a.find(\"xx\") == a.npos) cout &lt;&lt; \"Not Find\" &lt;&lt; endl;if (a.find(\"xx\") == string::npos) cout &lt;&lt; \"Not Find\" &lt;&lt; endl; 5. 替换，插入与删除12345678910111213141516string a = \"abcdefg\";/* 替换 */a.replace(2, 3, \"tttt\"); // 从2位置开始，长度为3的部分，替换为tttt。 // 最后输出结果为 abttttfg/* 插入 */a.insert(2, \"tttt\"); // 从2位置开始，插入tttt // 最后输出结果为 abttttcdefga.insert(0, \"tttt\"); //在开头插入a.insert(a.size(), \"tttt\"); // 在末尾插入/* 删除 */a.erase(2,3); // 删除 从第0位开始，长度为3的字符串。结果为 abfga.erase(0,2); // 删除前两个元素。结果为 cdefga.erase(3); // 删除位置3以后的所有字符。结果为 abc 6. 遍历三种常用的遍历方式： 12345678910111213string a = \"abcdefg\";// 方法 1：for (int i = 0; i &lt; a.size(); i++) cout &lt;&lt; a[i] &lt;&lt; endl;// 方法 2：for (char c : a) cout &lt;&lt; c &lt;&lt; endl;// 方法 3：迭代器for (string::iterator it = a.begin(); it != a.end(); ++it) cout &lt;&lt; *it &lt;&lt; endl; 7. 数值与字符串相互转换12345int b = stoi(\"121\"); // 字符串转为intfloat c = stof(\"12.345\"); // 字符串转为floatstring d = to_string(121); // int转为字符串string e = to_string(12.345); // float转为字符串 8. 排序123456789string a = \"Aa32Cc1bB\";// 升序排列：数字1-9 -&gt; 大写字母A-Z -&gt; 小写字母a-z （实际就是按照 ACSII 码从小到大排序）sort(a.begin(), a.end());cout &lt;&lt; a &lt;&lt; endl; // 结果为：123ABCabc// 降序排列：小写字母z-a -&gt; 大写字母Z-A -&gt; 数字9-1sort(a.begin(), a.end(), greater&lt;char&gt;());cout &lt;&lt; a &lt;&lt; endl; // 结果为：cbaCBA321 9. 杂项1234567string a = \"test\";// 末尾插入一个字符（注意，这里只能是字符）a.push_back('2');// 弹出最后一个字符a.pop_back();","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"AtCoder Beginner Contest 384 Summary","slug":"AtCoder_384_Summary","date":"2024-12-15T11:35:42.000Z","updated":"2025-01-04T11:57:52.302Z","comments":true,"path":"2024/blog/54122/","permalink":"http://example.com/2024/blog/54122/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）384 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）384 的总结笔记。 A - aaaadaaProblem：A - aaaadaa 签到题。将字符串 中不是 a 的字符全部改成 b。 1234567891011121314151617181920212223242526// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n;char a, b;string s;void solve() { cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; s; for (auto&amp; x : s) if (x != a) x = b; cout &lt;&lt; s &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - ARC DivisionProblem：B - ARC Division 模拟题。 按照题目要求做条件判断即可。 如果参加的是 div1 并且当前 rating 在 之间，就可以计入成绩 如果参加的是 div2 并且当前 rating 在 之间，就可以计入成绩 其他情况直接跳过 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, r;int d, a;bool check_div1(int r) { if (r &gt;= 1600 &amp;&amp; r &lt;= 2799) return true; return false;}bool check_div2(int r) { if (r &gt;= 1200 &amp;&amp; r &lt;= 2399) return true; return false;}void solve() { cin &gt;&gt; n &gt;&gt; r; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; d &gt;&gt; a; // 参加 div1，并且 rating 在 [1600,2799] 之间 if (d == 1 &amp;&amp; check_div1(r)) r += a; // 参加 div2，并且 rating 在 [1200,2399] 之间 else if (d == 2 &amp;&amp; check_div2(r)) r += a; // 否则跳过 else continue; } cout &lt;&lt; r &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Perfect StandingsProblem：C - Perfect Standings 位运算 + STL 题目：A B C D E 题分别对应 a b c d e 五个分值。 从只做出 A 题到全部做完 ABCDE ，共有 31 种组合情况。 按照分值从大到小输出各种做题的可能性，分值相同的时候，按照字典序输出。 思路：这道题虽然使用最暴力的手工枚举也可以做，但是太过麻烦。下面是更加通用的方法。 需要解决两个问题： 如何枚举所有的做题状态？ 本题总共有五位，所以可以使用一个五位的二进制数就可以枚举出各个题的解答状态。 如何按照分数降序 和 字典序升序的方式排列。 使用 struct 的时候，单独定义 cmp 比较算子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_c// 位运算#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int a[5];struct Score { int s; // 存储分值 int st; // 存储二进制状态 string str; // 存储对应的做题方案} s[50];// 自定义算子bool cmp(const Score&amp; a, const Score&amp; b) { if (a.s != b.s) { return a.s &gt; b.s; // s 不同时按 s 降序 } return a.str &lt; b.str; // s 相同时按 str 字典序升序}// 将二进制状态转化为字符串string make_str(int x) { string s = \"\"; for (int i = 0; i &lt; 5; i++) if (x &gt;&gt; i &amp; 1) s += 'A' + i; sort(s.begin(), s.end()); return s;}// 计算当前二进制状态的分值int cal_score(int x) { int res = 0; for (int i = 0; i &lt; 5; i++) if (x &gt;&gt; i &amp; 1) res += a[i]; return res;}void solve() { // 读入各个题目的分值 for (int i = 0; i &lt; 5; i++) cin &gt;&gt; a[i]; // 遍历所有 32 种状态，同时计算 分值 和 对应的字符串 for (int i = 0; i &lt;= 31; i++) { s[i].st = i; s[i].s = cal_score(i); s[i].str = make_str(i); } // 排序 sort(s, s + 32, cmp); // 输出结果（只输出前 31 个结果，第 32 个结果是空集，跳过） for (int i = 0; i &lt; 31; i++) cout &lt;&lt; s[i].str &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - Repeated SequenceProblem：D - Repeated Sequence 思维题 题目：给定长度为 的序列 。以这组序列为模板，无限重复循环。 是否能截取连续出子序列，使和恰好为 。 约束条件 思路：根据下图示例，我们可以发现，选取的子段由三部分组成：一个后缀，若干个周期 pattern，一个前缀。 由于任意的 都是正数，所以我们可以直接知道可以有多少个完整的 pattern，即 。 如果去除中间重复的 pattern，最后一定会剩下左边的一部分 left 和右边的一部分 right。那么 问题转化为，能不能找到一个后缀和一个前缀，使二者的和等于 。 最后剩下的部分，和的范围应该是 。 所以我们依次遍历左边部分的后缀和，同时维护一个 set，判断 set 里面有没有我们想要的值即可。总时间复杂度为 。（或者也可以直接使用二分，也可以达成相同的目的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int A[N];LL sum[N];LL n, s;set&lt;LL&gt; h;void solve() { // 读入数据，维护 前缀和 和 set cin &gt;&gt; n &gt;&gt; s; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; A[i]; sum[i] = sum[i - 1] + A[i]; h.insert(sum[i]); } s %= sum[n]; sum[n + 1] = sum[n]; bool can = false; // 从后往前逐个遍历 for (int i = n + 1; i &gt;= 1; i--) { // 计算出后缀和 LL left = sum[n + 1] - sum[i - 1]; // 计算出期待的前缀和 LL right = s - left; // 看是否存在 if (h.count(right)) can = true; if (h.count(right + sum[n])) can = true; if (can) break; } if (can) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Takahashi is Slime 2Problem：E - Takahashi is Slime 2 优先队列 BFS。本题和 ABC 383 的 E - Sinking Land 题目非常相似。 题目：给定 的网格。每个网格中有一个数值 。起始点位于 。 从起点向四方向移动。只有数值 严格小于当前累计值 res 的 的时候，才能吃掉这个格子。 求最大累加值。 约束条件： 思路：标准的优先队列 BFS 题目。按照题目写即可。 需要注意的一个细节点： ​ 题目要求“数值 严格小于当前累计值 res 的 的时候，才能吃掉这个格子”。这里的严格小于应该如何处理。如果直接写 s * X &lt; res 的话，在本题规模下会溢出。这里只需要计算 即可。代码写作 s &lt; (res+X-1)/X 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_e// 优先队列 BFS#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};const int N = 510;LL g[N][N];LL P, Q;LL H, W, X;LL res;bool st[N][N];// 创建结构体struct Node { LL x, y, score; // 重置小于符号（为小根堆做准备） bool operator&lt;(const Node&amp; a) const { return score &gt; a.score; }};priority_queue&lt;Node&gt; que;void solve() { // 读入数据 cin &gt;&gt; H &gt;&gt; W &gt;&gt; X &gt;&gt; P &gt;&gt; Q; for (int i = 1; i &lt;= H; i++) for (int j = 1; j &lt;= W; j++) { cin &gt;&gt; g[i][j]; } // 初始化 que.push((Node){P, Q, g[P][Q]}); st[P][Q] = true; res = 0; // 优先队列 BFS /* 注意：题目中要求，吸收单元格的 score 值必须严格小于 res/X 这里直接使用上取整，即 score &lt;(res+X-1)/X 即可满足要求 */ while (que.size() &amp;&amp; (res == 0 || que.top().score &lt; (res + X - 1) / X)) { Node now = que.top(); que.pop(); res += now.score; for (int i = 0; i &lt; 4; i++) { int a = now.x + dx[i], b = now.y + dy[i]; // 越界 if (a &lt; 1 || a &gt; H || b &lt; 1 || b &gt; W) continue; // 已经被看过了 if (st[a][b]) continue; // 加入优先队列 que.push((Node){a, b, g[a][b]}); st[a][b] = true; } } // 输出结果 cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} F - Double Sum 2Problem：F - Double Sum 2 数论题目。（这道题非常的抽象，很难理解） 题目：给定正整数 。定义 ：只要 还是偶数，就让他一直除以 ，最终剩下的值作为 的结果。 给定序列 ，求 的值。 约束条件： 思路： 技巧： 统计顺序的更改。核心思想：本题要求出 个数字的和，如果一个个统计，肯定会超时。可以把数字分成组，一次算出一组的和，最后再相加。 整体思路： 定义 为满足下面条件的所有 对应的 的总和 条件 1： 条件 2： 是 的倍数 ​ 也就是说， 是所有满足 的配对 的 的总和。 那么，如果 恰好能被 整除的 的和为 。 ​ 备注：这里可能稍微有点难理解。举个例子，一个数 如果能被 整除，那么它一定能被 整除。那么只能被 8 整除的部分的总和就是 最终所求的答案就是：将所有 的这种“刚好被 除以 次”的和，在分别除以 后再累加起来，即 。 细节问题处理： 根据上面的思路，于是问题就转变为：如何快速的求出 的值？ 我们可以知道： ，如果直接双层遍历，时间复杂度是 ，显然不行。 技巧：同余条件 等价于 也就等价于 。 所以当处理 j 位置时，我们希望知道： 在 的部分中，有多少个 满足 在 的时候，若 能够被 整除，则这一对也要计入 为了方便计数求和，我们可以用一个以 为键的 “字典 map” 来维护已经出现过的 的计数和总和。 map： 键 key： 值 value：在当前余数下出现的所有 的个数和总和 因此，当我们要处理 时，先计算出 ，然后在 map 中查找这个 key 是否存在。 若存在，就可以得到相匹配的 （满足条件的个数） 和 （满足条件的和），就可以快速求出 。 然后根据前面的公式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Problem: https://atcoder.jp/contests/abc384/tasks/abc384_f#include &lt;bits/stdc++.h&gt;using namespace std;// typedef long long LL;#define int long long // 本题中大量使用 ll，为了方便直接定义为 inttypedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10, M = 2e7 + 10;int n;int a[N];int sum[M]; // 存储累计和，A_i的上限是2e7，所以mp的idx不会超过这个数int cnt[M]; // 存储计数int d[30]; // 存储所有中间的 d 值void solve() { // 读入原始数据 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; int k = 1; // 即 2^0 // 遍历阶次 for (int j = 0; j &lt;= 24; j++) { // 从头遍历数组中的每个数 for (int i = 1; i &lt;= n; i++) { int key = a[i] % k; // mp[r]是a[i]%k后余数为r的所有数a[i]的累计和 sum[key] += a[i]; // cnt[r]是a[i]%k后余数为r的所有数出现次数 cnt[key]++; // 累计获得 d_j 的值 d[j] += sum[(k - a[i] % k) % k] + a[i] * cnt[(k - a[i] % k) % k]; } // mp 与 cnt 重置 for (int i = 1; i &lt;= n; i++) { int key = a[i] % k; sum[key] = 0; cnt[key] = 0; } k = k * 2; } // 计算出结果 int res = 0; k = 1; for (int i = 0; i &lt;= 24; i++) { res += (d[i] - d[i + 1]) / k; k *= 2; } cout &lt;&lt; res &lt;&lt; endl;}signed main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 383 Summary","slug":"AtCoder_383_Summary","date":"2024-12-09T04:23:12.000Z","updated":"2025-01-04T11:57:52.299Z","comments":true,"path":"2024/blog/58188/","permalink":"http://example.com/2024/blog/58188/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）383 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）383 的总结笔记。 A - Humidifier 1Problem：A - Humidifier 1 模拟题。非常的简单。 12345678910111213141516171819202122232425262728293031// Problem:#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;void solve() { int n; cin &gt;&gt; n; int res = 0, last_t = 0; for (int i = 1; i &lt;= n; i++) { int t, v; cin &gt;&gt; t &gt;&gt; v; if (res) res = max(res - (t - last_t), 0); res += v; last_t = t; } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - Humidifier 2Problem：B - Humidifier 2 暴力搜索。 由于数据范围非常小，网格最大也才 ，所以直接暴力枚举两个加湿器的位置，然后暴力计算每个点和加湿器的位置即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Problem: https://atcoder.jp/contests/abc383/tasks/abc383_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 15;char g[N][N];bool st[N][N];int res;int h, w, d;int check(int a, int b, int x, int y) { int ans = 0; for (int i = 0; i &lt; h; i++) for (int j = 0; j &lt; w; j++) if (g[i][j] == '.') if (abs(i - a) + abs(j - b) &lt;= d || abs(i - x) + abs(j - y) &lt;= d) { ans++; } return ans;}void solve() { cin &gt;&gt; h &gt;&gt; w &gt;&gt; d; for (int i = 0; i &lt; h; i++) for (int j = 0; j &lt; w; j++) cin &gt;&gt; g[i][j]; // 确定第一台的位置 for (int i = 0; i &lt; h; i++) for (int j = 0; j &lt; w; j++) { // 确定第二台的位置 for (int x = 0; x &lt; h; x++) for (int y = 0; y &lt; w; y++) { // 如果是同一个点，跳过 if (i == x &amp;&amp; j == y) continue; // 如果两个点都是 地板 if (g[i][j] == '.' &amp;&amp; g[x][y] == '.') { res = max(res, check(i, j, x, y)); } } } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Humidifier 3Problem：C - Humidifier 3 图论题目。 题目本质是在问每个格子到最近的 距离是多少。使用经典的 “虚拟节点” 方法转换为单源最短路问题。我的答案里把 1e6+5 作为了虚拟节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// Problem: https://atcoder.jp/contests/abc383/tasks/abc383_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 1e6 + 10, M = 20 * N;int h[N], e[M], w[M], ne[M], idx;int dist[N];int st[N];int H, W, d;char g[1010][1010];int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};void add(int a, int b, int c) { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++;}// SPFA 算法void spfa() { int start = 1e6 + 5; memset(dist, 0x3f, sizeof dist); dist[start] = 0; queue&lt;int&gt; q; q.push(start); st[start] = true; while (q.size()) { int now = q.front(); q.pop(); st[now] = false; for (int i = h[now]; i != -1; i = ne[i]) { int next = e[i]; if (dist[next] &gt; dist[now] + w[i]) { dist[next] = dist[now] + w[i]; if (!st[next]) { q.push(next); st[next] = true; } } } }}void solve() { // 读入网格数据 cin &gt;&gt; H &gt;&gt; W &gt;&gt; d; for (int i = 0; i &lt; H; i++) for (int j = 0; j &lt; W; j++) cin &gt;&gt; g[i][j]; // 建图 memset(h, -1, sizeof h); for (int i = 0; i &lt; H; i++) for (int j = 0; j &lt; W; j++) { // ‘#’点不建图 if (g[i][j] == '#') continue; int now = i * W + j; // ‘H’点额外添加和虚拟节点 1e6+5 的 0 边权的边 if (g[i][j] == 'H') { add(1e6 + 5, now, 0), add(now, 1e6 + 5, 0); } // 看一下周围四个点能不能建边 for (int k = 0; k &lt; 4; k++) { int a = i + dx[k], b = j + dy[k]; // 越界 if (a &lt; 0 || a &gt;= H || b &lt; 0 || b &gt;= W) continue; // 遇到 # if (g[a][b] == '#') continue; // 建边 add(now, a * W + b, 1); } } spfa(); // 遍历，看距离 H 在 d 以内的点有多少 int res = 0; for (int i = 0; i &lt; H; i++) for (int j = 0; j &lt; W; j++) if (g[i][j] != '#' &amp;&amp; dist[i * W + j] &lt;= d) res++; cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - 9 DivisorsProblem：D - 9 Divisors 数论题目。 能满足只有 9 个约数的数字实际上不多。 约数基本定理： ​ 一个数能被拆成若干个质数乘积的形式 ，那么 N 的约数个数为 。 按照上面定理的格式，9 只能被拆分为 或者 两种可能性。 ：表明数字 ，是某一个质数的 8 次方 ：表示数字 ，是某两个质数的平方和 思路： ​ 预处理出来质数表。分成两种情况遍历即可。这道题也并不需要真的预处理出来 这么多数字，只需要计算到 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Problem: https://atcoder.jp/contests/abc383/tasks/abc383_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const LL N = 2e6 + 10;LL primes[N], cnt;bool st[N];LL n;// 线性筛法模板void get_primes(LL x) { for (LL i = 2; i &lt;= x; i++) { if (!st[i]) primes[cnt++] = i; for (LL j = 0; primes[j] * i &lt;= x; j++) { st[i * primes[j]] = true; if (i % primes[j] == 0) break; } }}// 计算 x^4 的值LL pow_4(LL x) { return x * x * x * x;}void solve() { // 读入数据，计算平方根 cin &gt;&gt; n; LL intSqrt = sqrt(n) + 1; // 预处理质数表 get_primes(intSqrt); // 讨论 1*8 的情况 int res = 0; for (int i = 0; i &lt; cnt; i++) { if (pow_4(primes[i]) &lt; intSqrt) res++; // 防止溢出，超出界限直接 break，后面的再不算了 else break; } // 讨论 3*3 的情况 for (int i = 0; i &lt; cnt; i++) for (int j = i + 1; j &lt; cnt; j++) { LL temp = primes[i] * primes[j]; if (temp &lt; intSqrt) res++; // 防止溢出，超出界限直接 break else break; } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Sum of Max MatchingProblem：E - Sum of Max Matching 题目：给定一个 节点 条边，带正边权的简单无向图。对于从 到 的一条路径，路径权重为该路径经过的所有边的最大值。令 是从 走到 的所有路径的路径权重的最小值。 给定两个长度为 的序列 和 ， 可以自由排序，求 的最小值。 关键数据范围： The given graph is simple and connected. All input values are integers. 思路：这道题非常类似于 NOPI2013提高组的题目：506. 货车运输 - AcWing题库 题目解析： 表示从 走到 的所有路径中，最小的路径权重。例如： 如上述例子，有 。 直觉思路：二分 对于求类似 “最大值的最小值” 类型的题目，基本都可以使用二分思路来解决。 对于一个 值，将图中所有边权大于 的边全部删掉，看剩下的图的连通性。 本题思路：并查集+贪心 如果我们将所有的边按照边权升序排列，一条边一条边的添加进图。我们希望 的值尽可能的小，意味着需要 A 和 B 中的点尽可能早的进行匹配。那么每次加入一条边，就有可能会合并两个连通块，那么新加入的这条边的边权，一定是两个连通块之间 值的最小值。如果匹配成功了 对，那么就会产生 的 值。 详细可参考下面的示例： 备注：最后实际上生成的图是“最小生成树”，算法类似于 Kruskal 算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Problem: https://atcoder.jp/contests/abc383/tasks/abc383_e// 并查集 + 贪心#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;struct Edge { int w; int u, v;} e[N];bool cmp(Edge&amp; a, Edge&amp; b) { return a.w &lt; b.w ? true : false;}int A[N], B[N];int cnta[N], cntb[N]; // 连通块中，未匹配的A和B各个元素的数目int p[N]; // 并查集数组，存储每个元素的祖宗元素int n, m, k;// 找到 x 的祖宗节点int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x];}// 计算x和y点相连，能匹配成功多少对点int merge(int x, int y) { // 求 x 和 y 的根节点 int px = find(x), py = find(y); // 如果相同，说明他们已经在一个连通块了，不能再匹配了 if (px == py) return 0; // 把 x 并入 y 中 p[px] = py; // 将 px 连通块的 AB 计数加到 py 上 cnta[py] += cnta[px]; cntb[py] += cntb[px]; // 合并完成后，看看在 fy 为根的连通块中有多少对可以A与B相匹配 int tmp = min(cnta[py], cntb[py]); // 匹配完成，把匹配掉的A和B减掉。（因为已经成对了，不是未匹配的状态） cnta[py] -= tmp; cntb[py] -= tmp; // 返回这一次匹配成功了多少个点 return tmp;}void solve() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; // 读入所有的边 for (int i = 0; i &lt; m; i++) { int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; e[i] = {c, a, b}; } // 储存 A 和 B for (int i = 0; i &lt; k; i++) cin &gt;&gt; A[i]; for (int i = 0; i &lt; k; i++) cin &gt;&gt; B[i]; // 并查集初始化 for (int i = 1; i &lt;= n; i++) p[i] = i; // 按照边权升序排列 sort(e, e + m, cmp); // 预处理A和B中，每个元素的数量，存在cnta和cntb中 for (int i = 0; i &lt; k; i++) { cnta[A[i]]++; cntb[B[i]]++; } // 遍历每一条边 LL res = 0; for (int i = 0; i &lt; m; i++) { // 看加入i边后，能匹配多少对 res += merge(e[i].u, e[i].v) * e[i].w; } // 输出结果 cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} F - DiversityProblem：F - Diversity","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 382 Summary","slug":"AtCoder_382_Summary","date":"2024-12-02T09:46:52.000Z","updated":"2025-01-04T11:57:52.298Z","comments":true,"path":"2024/blog/29505/","permalink":"http://example.com/2024/blog/29505/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）382 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）382 的总结笔记。 A - Daily CookieProblem：A - Daily Cookie 省略。 B - Daily Cookie 2Problem：B - Daily Cookie 2 把字符串 后面的 个@改成 . 输出。 123456789101112131415161718192021222324252627282930// Problem: https://atcoder.jp/contests/abc382/tasks/abc382_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; for (int i = n - 1; i &gt;= 0; i--) { if (!k) break; if (s[i] == '@') { k--; s[i] = '.'; } } cout &lt;&lt; s &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Kaiten SushiProblem：C - Kaiten Sushi 贪心。 题目：有编号 的 个人，每个人有阈值 ，只吃超过阈值的食物。 有 的 份寿司，每个寿司有美味度 ，依次经过上面的每个人。只要美味度高于这个人，就会被这个人吃掉。 输出每份寿司被谁吃掉。 思路：对于 来说，只要是高于它阈值的寿司，都会被吃掉。所以将所有寿司按照降序排列，从头开始遍历 的各个人即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Problem: https://atcoder.jp/contests/abc382/tasks/abc382_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n, m;int A[N];PII B[N]; // 存储食物美味度 和 食物编号int res[N]; // 存储每个食物分给了谁// 降序排列bool cmp(const PII&amp; a, const PII&amp; b) { return a.first &gt; b.first;}void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; A[i]; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; B[i].first; // 食物美味度 B[i].second = i; // 食物编号 } sort(B, B + m, cmp); // 降序排列 memset(res, -1, sizeof res); // res 初始化 for (int i = 0, index = 0; i &lt; n; i++) { // 只要 接受值 小于等于 食物美味度，就吃掉 // index 如果超出 m 了，食物美味度就是 0，不影响后面的判断，不算越界 while (A[i] &lt;= B[index].first) { res[B[index].second] = i + 1; index++; } } // 输出结果 for (int i = 0; i &lt; m; i++) cout &lt;&lt; res[i] &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - Keep DistanceProblem：D - Keep Distance DFS + 剪枝 题目：打印长度为 并满足下面两个条件的字典序序列 ： 思路：题目中有个重要的约束条件：前一个数 与后一个数 距离相差 以上。 利用这个约束条件可以剪枝 DFS 的递归过程，大大减少时间复杂度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Problem: https://atcoder.jp/contests/abc382/tasks/abc382_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, m;vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; temp;void dfs(int x, int u) { // 当前序列长度达到n时 if (u == n) { res.push_back(temp); // 保存当前解 return; } // 超出界限，直接返回 if (x &gt; m) return; // 从x+10开始遍历，确保相邻数字差值至少为10 for (int i = x + 10; i &lt;= m - 10 * (n - 1 - u); i++) { temp.push_back(i); dfs(i, u + 1); temp.pop_back(); }}void solve() { cin &gt;&gt; n &gt;&gt; m; // 从1开始遍历数列 A 的第一个可能数字 for (int i = 1; i &lt;= m - 10 * (n - 1); i++) { temp.push_back(i); dfs(i, 1); // 已经放入一个数，所以u从1开始 temp.pop_back(); } // 输出每一组解 cout &lt;&lt; res.size() &lt;&lt; endl; for (auto&amp; x : res) { for (auto t : x) cout &lt;&lt; t &lt;&lt; \" \"; cout &lt;&lt; endl; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Expansion PacksProblem：E - Expansion Packs 概率题 题目：有无限个口袋，每个口袋里有 张卡片。第 张卡片位稀有卡的概率为 。 一个个打开口袋。求累计获得 张稀有卡的时候，打开口袋的期望值。 限制条件： 思路：TODO","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 381 Summary","slug":"AtCoder_381_Summary","date":"2024-11-24T07:52:42.000Z","updated":"2025-01-04T11:57:52.297Z","comments":true,"path":"2024/blog/33621/","permalink":"http://example.com/2024/blog/33621/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）381 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）381 的总结笔记。 A - 11/22 StringProblem：A - 11/22 String 题目：判断输入的字符串是否是形如 11/22 或者 111/222 的字符串。 思路：字符串长度为偶数：肯定不是 字符串长度为奇数：判断构造的字符串是否和原始字符串相同即可。 123456789101112131415161718192021222324252627282930// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n;string s;void solve() { cin &gt;&gt; n &gt;&gt; s; if (n % 2 != 1) cout &lt;&lt; \"No\" &lt;&lt; endl; else { string res = string(n / 2, '1') + \"/\" + string(n / 2, '2'); if (s != res) cout &lt;&lt; \"No\" &lt;&lt; endl; else cout &lt;&lt; \"Yes\" &lt;&lt; endl; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - 1122 StringProblem：B - 1122 String 问题：1122 字符串：形如 aabb aaccdd 的字符串，且各字母在字符串中只出现 次。 判断输入的字符串是否为 1122 字符串。 思路：字符串长度为奇数：肯定不是 字符串长度为偶数：使用 unordered_map 记录每个字符出现的次数。依次判断字符串中， 与 前后两个字符是否相同即可。 123456789101112131415161718192021222324252627282930313233343536// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;void solve() { string s; cin &gt;&gt; s; int len = s.size(); if (len % 2 != 0) cout &lt;&lt; \"No\" &lt;&lt; endl; else { s = \".\" + s; unordered_map&lt;int, int&gt; h; for (int i = 1; i &lt;= len; i++) h[s[i] - 'a']++; for (int i = 1; i &lt;= len / 2; i++) { if (s[2 * i] != s[2 * i - 1] || h[s[i] - 'a'] != 2) { cout &lt;&lt; \"No\" &lt;&lt; endl; return; } } cout &lt;&lt; \"Yes\" &lt;&lt; endl; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - 11/22 SubstringProblem：C - 11/22 Substring 题目：给定字符串 ，求连续的最长的 11/22 子串。 思路：双指针。 遍历字符串 ，找到/ 后，用双指针分别向两边前进，找到满足条件的最长长度即可。时间复杂度 。 12345678910111213141516171819202122232425262728293031323334// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;int n;void solve() { cin &gt;&gt; n &gt;&gt; s; int res = 0; for (int i = 0; i &lt; s.size(); i++) { if (s[i] == '/') { int j = 1; while (i - j &gt;= 0 &amp;&amp; i + j &lt; n &amp;&amp; s[i - j] == '1' &amp;&amp; s[i + j] == '2') j++; res = max(res, 2 * j - 1); } } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - 1122 SubstringProblem：D - 1122 Substring 题目：找到字符串 中的最长 1122 连续子串。 思路：双指针 / 滑动窗口。 关键是维护 left 和 right 两个指针。随着遍历 left 一点点向右边移动，都能找到一个延伸的最远的 right，使得 right-left 就是子串的最大长度。使用 unordered_map 来维护滑动窗口内部各个字母的数量。 极端情况下是 的时间复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_d// 双指针 / 滑动窗口#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int A[N];void solve() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; A[i]; int res = 0; unordered_map&lt;int, int&gt; h; for (int left = 0, right = 0; left &lt; n - 1; left++) { // 如果出现连续三个以上的相同字符，落到最后一对相同字符上面 while (left + 2 &lt; n &amp;&amp; A[left] == A[left + 1] &amp;&amp; A[left + 1] == A[left + 2]) left++; // 如果left 和 left+1 字符相同 if (A[left] == A[left + 1]) { // 就向右继续搜 if (right &lt; left || (right - left) % 2) { right = left; h.clear(); } // 约束条件：1. 不越界 2. 前后相同 3. 没出现过 while (right + 1 &lt; n &amp;&amp; A[right] == A[right + 1] &amp;&amp; !h[A[right]]) { h[A[right]] = 2; // right 向右跳两格 right += 2; } res = max(res, right - left); // left 向右跳 left++; h[A[left]] = 0; } } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - 11/22 SubsequenceProblem：E - 11/22 Subsequence 题目：给定长度为 的字符串 。有 次查询。每次查询返回 范围内最长的 11/22 子串。子串可以不连续。 约束条件： is a string of length consisting of 1, 2, and /. , , , and are integers. 思路：前缀和 + 2次二分 对于字符串 S，提前预处理出来1， 2 的前缀和数组 a 和 c。同时用数组 v 记录所有 / 出现的位置。 对于与每一个查询的 L 与 R，都可以使用二分，在 v 中找到在区间 [L,R] 内出现 / 的一组位置 pos。然后针对每一个pos，都可以用 的时间复杂度计算出在 中出现 1 的个数，和 在 区间中出现 2 的个数。就可以快速的求出来 区间内 11/22 字符串的最大长度了。极端情况下是 的时间复杂度。在 的数据规模下会 TLE。 算法的瓶颈在于：需要枚举 区间内的所有 / 出现的位置，在极端情况下是 的时间复杂度。需要对其进行优化。通过下图我们可以发现，在 区间内，左侧的 1 数量在逐渐增多，右侧的 2 数量在逐渐减少。越靠近中央，越是可以得到最优解。此处我们可以再次引入一次二分，找到 左侧1数量 第一次大于等于 右侧2数量 的位置，那么最优解一定在这个位置或者左侧。这样就可以将该步骤时间复杂度限制在 ，总时间复杂度为 ，就可以在限制时间内跑完程序了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// Problem: https://atcoder.jp/contests/abc381/tasks/abc381_e// 前缀和 + 2次二分#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5;int a[N], c[N]; // 分别记录 '1' '2' 的前缀和（出现次数）int n, q;string s;int v[N]; // 存储每个/的位置bool check(int mid, int L, int R) { // 计算 mid 左边 1 出现的次数 int num_1 = a[mid] - a[L - 1]; // 计算 mid 右边 2 出现的次数 int num_2 = c[R] - c[mid]; return num_1 &gt;= num_2;}void solve() { cin &gt;&gt; n &gt;&gt; q &gt;&gt; s; s = \" \" + s; // 预处理前缀和数组 int cnt = 0; for (int i = 1; i &lt;= n; i++) { a[i] = a[i - 1], c[i] = c[i - 1]; if (s[i] == '1') a[i]++; if (s[i] == '/') { v[cnt++] = i; } if (s[i] == '2') c[i]++; } int n; // 存储每个查询 vector&lt;PII&gt; k; for (int i = 0; i &lt; q; i++) { int L, R; cin &gt;&gt; L &gt;&gt; R; k.push_back({L, R}); } // 遍历每一个查询 for (auto t : k) { int res = 0; int L = t.first, R = t.second; // 找到 [L,R] 范围内 '/' 的出现范围 int l = lower_bound(v, v + cnt, L) - v; int r = upper_bound(v, v + cnt, R) - v - 1; // 如果区间内没有 ‘/’，直接输出 0 if (r &lt; l) { cout &lt;&lt; 0 &lt;&lt; endl; continue; } // 找到 左侧1数量 大于等于 右侧2数量 的最小值 while (l &lt; r) { int mid = (l + r) / 2; if (check(v[mid], L, R)) r = mid; else l = mid + 1; } int len = min(a[v[l]] - a[L - 1], c[R] - c[v[l]]); // 看一下前面那个点的情况，取长度的最大值 if (l - 1 &gt;= 0 &amp;&amp; v[l - 1] &gt;= L) len = max(len, min(a[v[l - 1]] - a[L - 1], c[R] - c[v[l - 1]])); res = 2 * len + 1; cout &lt;&lt; res &lt;&lt; endl; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} F - 1122 SubsequenceProblem：F - 1122 Subsequence 题目：给定长度为 的序列 ，求序列中最长的 1122 字符串子串（可以不连续）。 约束条件： 思路： 小 tips： 从数据范围可以发现， 的最大值是 20。这是个很有趣的数字。如果是全排列，那么 ，不在考虑范围内。但 就显得刚刚好。 经验数值： 数值 对应可能的时间复杂度 10 或者 或者 …有很多可能性 20 200 或 300 500 1000 或 5000 或 或 状态压缩 DP。 TODO。","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 380 Summary","slug":"AtCoder_380_Summary","date":"2024-11-18T13:10:54.000Z","updated":"2025-01-04T11:57:52.296Z","comments":true,"path":"2024/blog/4952/","permalink":"http://example.com/2024/blog/4952/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）380 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）380 的总结笔记。 A - 123233Problem：A - 123233 题目：给定一个 6 位整数 。判断这个整数内是否刚好出现了 次 1, 次 2, 次 3。 思路：按照字符串读入，直接排序，看结果和 122333 是否相同即可。 123456789101112131415161718192021222324252627282930313233343536373839404142// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;// 无脑写法void solve1() { string s; cin &gt;&gt; s; int a = 0, b = 0, c = 0; for (auto x : s) { if (x == '1') a++; if (x == '2') b++; if (x == '3') c++; } if (a == 1 &amp;&amp; b == 2 &amp;&amp; c == 3) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}// 推荐写法：void solve2() { string s; cin &gt;&gt; s; sort(s.begin(), s.end()); cout &lt;&lt; (s == \"122333\" ? \"Yes\" : \"No\") &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); // solve1(); // 解法 1 solve2(); // 解法 2 return 0;} B - Hurdle ParsingProblem：B - Hurdle Parsing 题目：给定一个字符串，仅由 | 和 - 构成。输出两个 | 之间 - 的数量。 思路：维护一个变量 now： 当遇到 - 时 now 自增计数； 当遇到 | 时保存 now 的值，并清零。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;// 双指针做法void solve1() { string s; cin &gt;&gt; s; vector&lt;int&gt; res; int last = 0; for (int i = 1; i &lt; s.size(); i++) { int j = i; while (j &lt; s.size() &amp;&amp; s[j] != '|') j++; res.push_back(j - last - 1); i = j; last = j; } for (auto x : res) cout &lt;&lt; x &lt;&lt; \" \"; cout &lt;&lt; endl;}// 推荐写法：更具有编程思维void solve2() { string s; cin &gt;&gt; s; vector&lt;int&gt; res; int now = 0; for (int i = 0; i &lt; s.size(); i++) { if (s[i] == '|') res.push_back(now), now = 0; else now++; } for (int i = 1; i &lt; res.size(); i++) cout &lt;&lt; res[i] &lt;&lt; \" \"; cout &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); // solve1(); solve2(); return 0;} C - Move SegmentProblem：C - Move Segment 题目：给定长度为 的字符串 ，仅由 0 和 1 构成。 把第 个 1 block 移动到第 个 1 block 后面，重新输出字符串。 思路：解法 1：按照块来寻找。每次找到当前 1 block 的起点 st 和终点 ed，同时保存上一个 1 block 的起点 last_st 和终点 last_ed。数到第 个 1 block 的时候，使用 substr 将字符串重新拼接输出即可。 解法 2：将原字符串整理到一个 vector&lt;PII&gt; 中。每个 PII 元素同时保存了出现的字符 和 出现的次数。 只需将第 次出现 1 和他前面的元素交换位置，重新输出即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;// 解法 1：使用字符串拼接void solve1() { int n, k; cin &gt;&gt; n &gt;&gt; k; string s; cin &gt;&gt; s; string res; int last_start = 0, last_ed = 0; int start = 0, ed = 0; int cnt = 0; for (int i = 0; i &lt; s.size(); i++) { int j = i; // 找第一次 1 出现的起点 while (j &lt; s.size() &amp;&amp; s[j] != '1') j++; start = j; // 找 1 出现的终点 while (j &lt; s.size() &amp;&amp; s[j] == '1') j++; ed = j - 1; if (cnt == 0) { last_start = start, last_ed = ed; } cnt++; if (cnt == k) { res = s.substr(0, last_ed + 1) + s.substr(start, ed - start + 1) + s.substr(last_ed + 1, start - last_ed - 1) + s.substr(ed + 1); break; } i = j - 1; if (cnt &gt; 1) { last_start = start, last_ed = ed; } } cout &lt;&lt; res &lt;&lt; endl;}// 解法 2：void solve2() { int n, k; string s; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; s += \".\"; // 技巧：防止越界，保证最后一段也被记录 vector&lt;PII&gt; v; int now = s[0], num = 0; for (int i = 0; i &lt; s.size(); i++) { if (s[i] == now) num++; // 计算段内长度 else { v.push_back({now - '0', num}); // 记录这一段的数据:{符号，长度} now = s[i], num = 1; } } int cnt = 0; for (int i = 0; i &lt; v.size(); i++) { // 找到第 k 段为 1 的位置 if (v[i].first == 1) { cnt++; if (cnt == k) // 交换位置 swap(v[i], v[i - 1]); } } // 重新输出 for (auto x : v) { for (int i = 0; i &lt; x.second; i++) cout &lt;&lt; x.first; } cout &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); // solve1(); solve2(); return 0;} D - Strange MirroringProblem：D - Strange Mirroring 递归 题目：给定一个字符串 ，包含大小写字母。 对 执行下面操作 次。 创建字符串 ，是将 中的大小写颠倒。然后将 接到 后面。 进行 次查询：返回 的第 个字母。 约束条件： is a string consisting of uppercase and lowercase English letters, with length between and , inclusive. and are integers. 思路：这道题思路很抽象。如下图，以 aBd 为例。 可以发现经过 次操作后，字符串总长度变为了 。 对于查询位置 x 的字符，我们总是能够找到 x 前面距离最近的 ，计算出与他的距离 L，我们就能推导出它在上一步操作中的位置。以此为递归的依据，最终能够找到它在原始字符串中的位置。 根据记录的跳转次数： 如果是奇数次，则发生大小写转换； 如果是偶数次，则保持原样。 因此，对于任意大的数字，都可以在 的时间复杂度内完成单次查询。 完成 次查询总时间复杂度为 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_d// 这是一道非常典型的递归题目#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;int t;// 大小写转换// ascii 码中：A 为65，a 为 97，相差 32char change(char ch) { return ch &gt;= 'a' ? (ch - 32) : (ch + 32);}// 递归char f(LL x, bool is_reverse) { // 如果已经到了最前面 if (x &lt;= s.size()) { // 如果需要翻转 if (is_reverse) return change(s[x - 1]); // 不需要翻转 else return s[x - 1]; } LL k = s.size(); // 找到距离 x 左边最近的倍数 while (k * 2 &lt; x) k *= 2; // 减去这个长度，向前找 return f(x - k, !is_reverse);}void solve() { cin &gt;&gt; s &gt;&gt; t; while (t--) { LL x; cin &gt;&gt; x; cout &lt;&lt; f(x, false) &lt;&lt; \" \"; } cout &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - 1D Bucket ToolProblem：E - 1D Bucket Tool 并查集处理区间染色问题。 题目：有编号 的 个格子排成一行。每个格子的初始颜色为 。 给定 次查询，查询有下面两种情况： 1 x c ：把 x 能到达的所有格子都涂成 c 颜色。 2 c：打印颜色为 c 的格子的数量。 约束条件： …… 思路：使用并查集来处理区间染色问题。 并查集在记录连通块的同时，还要维护额外的三个数组值： 区间的左端点 l 区间的右端点 r 集合内部的节点数 cnt 详细参照下面代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// Problem: https://atcoder.jp/contests/abc380/tasks/abc380_e// 使用并查集处理区间染色问题#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e6 + 10;// 节点的父节点，每个集合的节点数，集合的最左端点，集合的最右端点int fa[N], cnt[N], l[N], r[N];int color[N]; // 节点 i 的颜色int color_cnt[N]; // 颜色 i 的数量int n, q;// 查找节点 x 所属的集合int _find(int x) { // 如果 x 是根节点，就返回 x // 如果不是，就继续找祖宗。同时进行路径压缩 return x == fa[x] ? x : fa[x] = _find(fa[x]);}// 将 x 所在集合涂成颜色 cvoid paint(int x, int c) { x = _find(x); // 找 x 的祖宗 color_cnt[color[x]] -= cnt[x]; // 从原来的颜色计数中减去整个集合的大小 color[x] = c; // 染色 color_cnt[c] += cnt[x]; // 新颜色计数中添加整个集合大小}// 合并两个集合void _union(int x, int y) { int fx = _find(x), fy = _find(y); // 找到两个节点的祖宗节点 fa[fx] = fy; // fx 的祖宗改为 fy l[fy] = min(l[fx], l[fy]); // 更新合并后集合的左边界 r[fy] = max(r[fx], r[fy]); // 更新合并后集合的右边界 cnt[fy] += cnt[fx]; // 更新合并后集合的节点数量}void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; q; // 将每个节点 for (int i = 1; i &lt;= n; i++) { // 初始化：每个节点的颜色，父节点，左边界，右边界 color[i] = fa[i] = l[i] = r[i] = i; cnt[i] = 1; // 初始化：每个集合计数，只有一个节点 color_cnt[i] = 1; // 初始化：每种颜色只有一个节点 } while (q--) { int op; cin &gt;&gt; op; // 操作 1：染色操作 if (op == 1) { int x, c; cin &gt;&gt; x &gt;&gt; c; // 读入要染色的节点和 x 和目标颜色 c paint(x, c); // 染色 // 检查并合并相邻的同色集合 int L = l[_find(x)], R = r[_find(x)]; // 如果左边相邻集合同色 if (color[_find(L - 1)] == c) _union(L - 1, x); // 如果右边相邻集合同色 if (color[_find(R + 1)] == c) _union(R + 1, x); } // 操作 2：查询操作 else { int c; cin &gt;&gt; c; cout &lt;&lt; color_cnt[c] &lt;&lt; endl; } }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 379 Summary","slug":"AtCoder_379_Summary","date":"2024-11-11T09:55:33.000Z","updated":"2025-01-04T11:57:52.303Z","comments":true,"path":"2024/blog/29442/","permalink":"http://example.com/2024/blog/29442/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）379 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）379 的总结笔记。 A - CyclicProblem：A - Cyclic 太简单，省略。 1234567891011121314151617181920// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII; string s;void solve() { cin &gt;&gt; s; cout &lt;&lt; s[1] &lt;&lt; s[2] &lt;&lt; s[0] &lt;&lt; \" \" &lt;&lt; s[2] &lt;&lt; s[0] &lt;&lt; s[1] &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - StrawberriesProblem：B - Strawberries STL + 贪心。 1234567891011121314151617181920212223242526272829303132// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;int n, k;void solve() { cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; string gd(k, 'O'); // 健康牙齿的 pattern string bd(k, 'X'); // 蛀牙的 pattern int res = 0; // 找健康牙齿的 pattern while (s.find(gd) != s.npos) { s.replace(s.find(gd), k, bd); // 替换成蛀牙 pattern res++; // 计数 } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Sowing StonesProblem：C - Sowing Stones 推公式 题目：编号 的 个格子排成一列。其中 个格子有石子，格子 含有 个石子。 执行下面操作任意次（可以为 0） 如果 格子有石子，就从 移动一个石子到 让 个格子恰好每个只有一个石子，则最少进行多少次操作。如果不能，输出 -1 约束条件： 思路：这道题思路有些抽象。 我们希望通过若干次操作，使每个格子中都恰好有 个石子。 ​ 那么首先必须保证：石子的总量等于 N。 ​ 其次，必须保证：前 个格子中，至少有 个石子才能填满前面的空位。要求初始分布中的石子满足这个要求。即：如果从前往后看到 格子时，已累计的石子数量少于 时，就无法填满前面的格子。 这里引入一个概念：位置和 ​ 如果一个石子在位置 上，那么这颗石子对位置和的贡献就是 ​ 每进行一次操作，就会使某一颗石子的位置编号增加 。相当于是这颗石子从位置 移动到了 ，相应的对位置和的贡献从 变成了 ） ​ 意味着：如果初始位置和是 ，最终位置和是 ，那么要从 增加到 ，就必须执行 次增加位置和 的操作。 如何求操作次数呢？ ​ 初始状态下，石子的位置和为： ​ 最终状态下，石子的位置和为： ​ 每一次操作是将一颗石子从位置 移动到 ，相当于是位置和增加 ​ 因此为了从初始位置和变成最终位置和，需要的操作次数是： 总时间复杂度为 ，前半部分是排序的复杂度，后半部分是从头到后遍历一次。 备注：为什么会引入位置和这个概念呢？ 综上思路，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;LL n, m;struct Node { LL x; // 存储位置 LL a; // 存储石子数量} stone[N];bool cmp(const Node&amp; a, const Node&amp; b) { return a.x &lt; b.x;}void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) cin &gt;&gt; stone[i].x; for (int i = 0; i &lt; m; i++) cin &gt;&gt; stone[i].a; // 升序排列 sort(stone, stone + m, cmp); LL sum = 0; // 记录石子数量的累计和 LL pos_sum = 0; // 记录累计的位置和 for (int i = 0; i &lt; m; i++) { // 如果石子的累计数量 无法填满前面的空格，结束程序 if (sum &lt; stone[i].x - 1) { cout &lt;&lt; -1 &lt;&lt; endl; return; } sum += stone[i].a; // 更新石子数量的累计和 pos_sum += stone[i].x * stone[i].a; // 更新累计的位置和 } // 如果石子数量不对 if (sum != n) { cout &lt;&lt; -1 &lt;&lt; endl; return; } // 输出结果 cout &lt;&lt; n * (n + 1) / 2 - pos_sum &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - Home GardenProblem：D - Home Garden 队列 题目：高桥有很多花盆。最开始没有种植物。 按照顺序处理 次询问。询问有下面三种： 1 ：准备一个空花盆，种一棵植物，初始高度为 2 T ：等待 天。这之后，所有的植物高度都会增加 3 H：收割所有高度高于 的植物，并输出收割了多少。 约束条件： 思路：两个核心的思想： ​ 先种的植物肯定先被收获。（后种的植物不可能比前面种的植物长得更高）。先进先出就可以使用队列。 ​ 队列里面存什么？存种下的时间 。那么经过一段时间后，现在的时间 减去种下的时间 ，差值就是植物的高度 。满足条件就可以 pop（也就是收割）。 综上：使用队列来管理种入的时间。并额外维护一个当前的时间。 整体的时间复杂度为 ，同时所有的数据最多进队出队仅一次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int q;int op;LL x;void solve() { cin &gt;&gt; q; queue&lt;LL&gt; Q; // 队列 LL now = 0; // 记录当前时间 while (q--) { cin &gt;&gt; op; // 种植物 if (op == 1) { Q.push(now); } // 等待 x 天 else if (op == 2) { cin &gt;&gt; x; now += x; } // 收割高于 x 的植物 else { cin &gt;&gt; x; int res = 0; while (Q.size() &amp;&amp; now - Q.front() &gt;= x) { res++; Q.pop(); } cout &lt;&lt; res &lt;&lt; endl; } }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Sum of All SubstringsProblem：E - Sum of All Substrings 题目：给定长度为 的字符串 ，只包含数字 对于每一个整数对 ，定义 为 的从 到 的子串转化为整数后得到的值。 求 约束条件： 思路：直观来看有两种思路，下面将分别介绍： 思路 1：看字符串中的每一位对结果的贡献我们举如下的例子进行分析： 从上面的例子我们可以分析出： 第一位 ：能构成的子串只有 3，为最终的结果做出的贡献是 第二位 ：与前面的各个位置构成的子串是 37 7，相加的结果可以转换为 第三位 ：与前面的各个位置构成的子串是 379 79 9，相加的结果可以转换为 最后所有相加得 ，刚好是正确的结果 我们可以发现，在前一个位数中计算出来的结果，可以在下一位中乘以 10 倍，加上当前位置数字和出现次数的乘积，就是本轮结果为最终答案做出的贡献。 由于原字符串数字位数非常的大，所以要使用高精度来进行结算。 但是分析可知，时间复杂度非常的巨大，是 ，在本题目会超时。 思路 2：看结果中的每一位，是从字符串哪些地方来的简单来说，我们可以分析一下结果中的个位，十位和百位的数字，都是从原字符串中的什么地方贡献出来的。 根据上面的例子，我们可以分析出结果的每一位，是由原字符串的哪些部分贡献出来的。 很容易发现，绿色的部分，实际上是前缀和。 本题可以视为是 C 题 “位置和” 思路的延续。最终时间复杂度为 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 22e6 + 10;LL a[N]; // 存储字符串每一位的原数字LL b[N]; // 存储前缀和int n; // 字符串长度string s;void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; s; // 将每一位转化为数字，存在 a 数组中 // 并且将 0-base 转化为 1-base for (int i = 1; i &lt;= n; i++) a[i] = s[i - 1] - '0'; // 计算每一位，对该位置的权重 for (int i = 1; i &lt;= n; i++) b[i] = a[i] * i; // 计算前缀和 for (int i = 1; i &lt;= n; i++) b[i] += b[i - 1]; // 从后往前，对每一位进行大数进位 for (int i = n; i &gt;= 1; i--) { // 计算进位 b[i - 1] += b[i] / 10; // 求出当前位的数值 b[i] %= 10; } // b[0] 存储最后的进位 if (b[0] != 0) cout &lt;&lt; b[0]; // 从高位到低位输出 for (int i = 1; i &lt;= n; i++) cout &lt;&lt; b[i]; cout &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} F - Buildings 2Problem：F - Buildings 2 单调栈 + 二分 题目：有编号 的 栋建筑，分别有不同的高度 。 对于整数对 ，如果 和 之间，没有比 高的建筑，那么可以从建筑 看到建筑 。 给定 个查询，每个查询中给定一个整数对 ，求出 后面，能同时被 和 都看到的建筑物的数量。 约束条件： 思路：（备注：本题我还没有弄懂，就暂时先把代码存起来！） 题目要求，如果 后面的一栋楼 ，需要同时满足下面两点： 从 能看到 从 能看到 本题是“可见楼”问题。许多“可见楼” 问题都可以用单调栈（Monotonic Stack）来做快速处理。 TODO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Problem: https://atcoder.jp/contests/abc379/tasks/abc379_f#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 1e6 + 10;int n, q;int a[N]; // 存放楼的高度int s[N], t; // s[] 用作单调栈, t 表示栈的大小(或当前栈顶位置)int ans[N]; // 存储最终结果vector&lt;PII&gt; query[N]; // 存储所有左端点为i的查询void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; // 读入查询 for (int i = 1; i &lt;= q; i++) { int l, r; cin &gt;&gt; l &gt;&gt; r; /* 这里的存储方式很技巧： index：查询的左端点 value：pair 存储查询的右端点 和 查询编号 */ query[l].push_back({r, i}); } // 从后往前看每一栋楼 for (int i = n; i &gt; 0; i--) { // 取出来左端点为 i 的所有查询 for (auto p : query[i]) { // 在单调栈 s 里二分，找到大于 r 的最小值 int L = 1, R = t; while (L &lt; R) { int mid = (L + R + 1) / 2; if (s[mid] &gt; p.first) L = mid; else R = mid - 1; } // 说明无解 if (s[L] &lt;= p.first) ans[p.second] = 0; // L 就是结果 else ans[p.second] = L; } while (t &amp;&amp; a[s[t]] &lt; a[i]) t--; s[++t] = i; } for (int i = 1; i &lt;= q; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 378 Summary","slug":"AtCoder_378_Summary","date":"2024-11-06T02:02:49.000Z","updated":"2025-01-04T11:57:52.295Z","comments":true,"path":"2024/blog/58127/","permalink":"http://example.com/2024/blog/58127/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）378 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）378 的总结笔记。 A - PairingProblem：A - Pairing 省略。 1234567891011121314151617181920212223242526272829// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int f[4];void solve() { for (int i = 0; i &lt; 4; i++) { int c; cin &gt;&gt; c; f[c]++; } int res = 0; for (int i = 1; i &lt;= 4; i++) res += f[i] / 2; cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - Garbage CollectionProblem：B - Garbage Collection 模拟题。 省略。 12345678910111213141516171819202122232425262728293031323334353637// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 110;int q[N], r[N];int n, Q;void solve() { // 读入数据 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; q[i] &gt;&gt; r[i]; cin &gt;&gt; Q; for (int i = 1, t, d; i &lt;= Q; i++) { cin &gt;&gt; t &gt;&gt; d; int tmp = d % q[t]; // 如果 tmp 在 r[t] 前面，说明本轮就可以扔 if (tmp &lt;= r[t]) cout &lt;&lt; d + (r[t] - tmp) &lt;&lt; endl; // 否则要等到下一轮才能扔 else cout &lt;&lt; d + q[t] - tmp + r[t] &lt;&lt; endl; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - RepeatingProblem：C - Repeating STL 输出一个数字前面，离他最近的相同数字的位置。没有就输出 -1。 思路非常的简单，使用一个 unordered_map 来存储每个数字的出现位置。 1234567891011121314151617181920212223242526272829// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, a;unordered_map&lt;int, int&gt; q;void solve() { cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a; if (!q.count(a)) cout &lt;&lt; -1 &lt;&lt; \" \"; else cout &lt;&lt; q[a] &lt;&lt; \" \"; q[a] = i; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - Count Simple PathsProblem：D - Count Simple Paths DFS。 一道非常标准的 DFS 题目。难度不大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 15;string g[N]; // 存储网格bool st[N][N]; // 存储遍历状态int n, m, k;int res;int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};void dfs(int x, int y, int k) { if (k == 0) { res++; return; } for (int i = 0; i &lt; 4; i++) { int a = x + dx[i], b = y + dy[i]; if (a &lt; 1 || a &gt; n || b &lt; 1 || b &gt; m) continue; if (g[a][b] == '#' || st[a][b]) continue; st[a][b] = true; dfs(a, b, k - 1); st[a][b] = false; }}void solve() { // 读入数据，1-base cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; g[i]; g[i] = \" \" + g[i]; } // 对于每个点都 DFS 一遍 for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (g[i][j] == '#') continue; st[i][j] = true; dfs(i, j, k); st[i][j] = false; } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Mod Sigma ProblemProblem：E - Mod Sigma Problem 推公式 + 树状数组BIT 题目：给定一组长度为 的序列 ，给定一个正整数 。 求 。 约束条件： 思路 ：本题整体需要解决下面两个问题： 问题 1：公式化简我们定义带模前缀和为 那么我们就可以将原公式转化为 根据常用的知识点： ，我们就可以将 mod 符号从公式中去除掉，原公式转化为： 备注：照理说前缀和中， 是单调递增的，为什么会出现逆序对呢？ 本题中使用的是带模前缀和，所以真实的 值会呈现周期性的变化，当超过 时候，又会跳回到一个比较小的数值范围，所以就可能出现 的情况出现，就对应了本题中需要加入一个偏置 M 把结果“扳正”的情况。 从上面公式可以发现，公式最后可以被拆成 3 个部分： ：直接使用预处理好的带模前缀和计算，时间复杂度为 ：类似于前缀和的前缀和，拆开之后可以发现下图规律。化简结果为：。时间复杂度 。 ：问题就转化为，如何快速求出带模前缀和 s 的所有逆序对数量？ 使用树状数组 BIT 来解决。 问题 2：使用 BIT 求逆序对逆序对的定义是：找到所有的 使得 并且 。 如何使用 BIT 求逆序对的数量呢？ 假设从左向右遍历数组，当处理到 的时候，数组 都已经被放入了 BIT 中。将数字 作为 index，将出现次数作为 BIT 内存的值。我们可以很容易就求出，已经存入的数字中，比 小的数字有 个。相应的，比 大的数字数量为 这一步的时间复杂度为 总结：本题的整体思路为：首先将公式进行推到化简，可以发现分别求出三个部分的值就可以得出最终的结果。最麻烦的是如何求整体的逆序对数量，这里使用了 BIT 的数据结构。 整体的时间复杂度为 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n, m;int a[N]; // 储存原数组int s[N]; // 储存：带模前缀和int tr[N]; // BITint lowbit(int x) { return x &amp; -x;}// 更新 BIT 的值void add(int x, int k) { x++; for (int i = x; i &lt;= N; i += lowbit(i)) tr[i] += k;}// 求前x个数的数量和int sum(int x) { x++; int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res;}void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i]; // 预处理带模前缀和 s[i] = (s[i - 1] + a[i]) % m; } LL res = 0; // 计算公式的第一部分 for (int r = 1; r &lt;= n; r++) res += 1ll * s[r] * r; // 计算公式的第二部分 for (int l = 1; l &lt;= n; l++) res -= 1ll * s[l - 1] * (n - l + 1); // 计算逆序对 LL cnt = 0; for (int i = 1; i &lt;= n; i++) { cnt += (i - 1 - sum(s[i])); add(s[i], 1); } // 计算公式第三部分 res += 1ll * m * cnt; // 输出结果 cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} F - Add One Edge 2Problem：F - Add One Edge 2 题目：给定一个树，有 N 个节点，N-1 条边。 给树增加一条边，能把树变成恰好带一个环的图。 请问有多少个图满足条件：简单图，环上的所有顶点读数为 3。 约束条件： 思路：这道题目结论比较暴力： ​ 直接找度数为 的连通块，然后向外找度数为 的点。假设度数为 的点数量为 ，那么这些度数为 的点直接两两相连，都能形成题目要求的环。形成环的数量为 由于是把所有的点都看过，所以极限状态下的时间复杂度为 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// Problem: https://atcoder.jp/contests/abc378/tasks/abc378_f#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10, M = 4e5 + 10;int h[N], e[M], ne[M], idx; // 存储图int n;int deg[N]; // 记录度数bool st[N]; // 记录是否被看过int cnt; // 记录点的数量LL res; // 记录结果// 建图加边void add(int a, int b) { e[idx] = b; ne[idx] = h[a]; h[a] = idx++;}// DFSvoid dfs(int now, int fa = 0) { // 如果当前点度数不为 3 if (deg[now] != 3) { // 如果度数是 2，就计数 cnt += (deg[now] == 2); return; } // 此点标记 st[now] = true; // 看一下周围的点 for (int i = h[now]; i != -1; i = ne[i]) { int next = e[i]; // 如果是来时的点就跳过 if (next == fa) continue; // 向下搜 dfs(next, now); }}void solve() { // h 数组初始化 memset(h, -1, sizeof h); // 读入数据，同时预处理各个节点的度数 cin &gt;&gt; n; for (int i = 1; i &lt;= n - 1; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; add(u, v), add(v, u); deg[u]++, deg[v]++; } // 依次遍历每个节点 for (int i = 1; i &lt;= n; i++) { // 度数不为 3，直接跳过 if (deg[i] != 3) continue; // 如果这个点已经看过了，跳过 if (st[i]) continue; // 计算当前连通块，周围度数为 2 的点的数量 cnt = 0; dfs(i); res += 1ll * cnt * (cnt - 1) / 2; } // 输出结果 cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 377 Summary","slug":"AtCoder_377_Summary","date":"2024-10-28T17:59:01.000Z","updated":"2025-01-04T11:57:52.295Z","comments":true,"path":"2024/blog/4942/","permalink":"http://example.com/2024/blog/4942/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）377 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）377 的总结笔记。 A - Rearranging ABCProblem：A - Rearranging ABC 省略。 123456789101112131415161718192021222324// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;string s;void solve() { cin &gt;&gt; s; sort(s.begin(), s.end()); if (s == \"ABC\") cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - Avoid Rook AttackProblem：B - Avoid Rook Attack 省略。 1234567891011121314151617181920212223242526272829303132333435363738// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 10;char g[N][N];int col[N], row[N]; // 记录该行该列是否被占用void solve() { // 读入网格数据 for (int i = 0; i &lt; 8; i++) cin &gt;&gt; g[i]; // 记录行列占用情况 for (int i = 0; i &lt; 8; i++) for (int j = 0; j &lt; 8; j++) if (g[i][j] == '#') col[j] = row[i] = 1; // 判断每个点是否安全 int res = 0; for (int i = 0; i &lt; 8; i++) for (int j = 0; j &lt; 8; j++) if (!row[i] &amp;&amp; !col[j]) res++; cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Avoid Knight AttackProblem：C - Avoid Knight Attack STL 题目：一个 N*N 的网格。骑士可以按照下面形式攻击周围的 8 个格子。 输出网格上有多少安全点。 约束条件： 思路：题目的关键在于如何“去重”。 方法 1：（稍微麻烦一些）使用 unordered_map&lt;int, unordered_set&lt;int&gt; &gt;，其中，第一维度用来存储 x 坐标，第二维度用于存储 y 坐标，unordered_set 就会自动对 y 的坐标进行去重。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int dx[8] = {2, 1, -1, -2, -2, -1, 1, 2}, dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};int n, m;int a[N], b[N]; // 存储棋子的放置位置unordered_map&lt;int, unordered_set&lt;int&gt; &gt; occupation;bool check(int x, int y) { // 如果超出范围 if (x &lt; 1 || x &gt; N || y &lt; 1 || y &gt; N) return false; return true;}void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; a[i] &gt;&gt; b[i]; // 将棋子的位置标记为已占用 occupation[a[i]].insert(b[i]); } // 存储每一个棋子的攻击范围 for (int i = 1; i &lt;= m; i++) { for (int j = 0; j &lt; 8; j++) { int next_a = a[i] + dx[j]; int next_b = b[i] + dy[j]; if (check(next_a, next_b)) { occupation[next_a].insert(next_b); } } } // 开始计算总共被占用了多少位置 LL oc = 0; for (auto [x, y] : occupation) oc += (LL)y.size(); // 计算剩下了多少位置 cout &lt;&lt; (LL)n * n - oc &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} 方法 2：（好写一些）set&lt;pair&lt;int,int&gt;&gt; 可以自动对整数对去重。但是 unordered_set&lt;pair&lt;int,int&gt;&gt; 不行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int dx[8] = {2, 1, -1, -2, -2, -1, 1, 2}, dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};int n, m;int a[N], b[N]; // 存储棋子的放置位置set&lt;PII&gt; occupation;bool check(int x, int y) { // 如果超出范围 if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n) return false; return true;}void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i++) { cin &gt;&gt; a[i] &gt;&gt; b[i]; // 将棋子的位置标记为已占用 occupation.insert({a[i], b[i]}); } // 存储每一个棋子的攻击范围 for (int i = 1; i &lt;= m; i++) { for (int j = 0; j &lt; 8; j++) { int next_a = a[i] + dx[j]; int next_b = b[i] + dy[j]; if (check(next_a, next_b)) occupation.insert({next_a, next_b}); } } // 计算剩下了多少位置 LL res = (LL)n * n - occupation.size(); cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - Many Segments 2Problem：D - Many Segments 2 贪心 题目：给定长度为 的两个正整数数列 和 给定正整数 求出满足下面条件的整数对 的个数。 区间 不会完整的包含区间 约束条件： 思路：如果我们锁定一个 ，那么 最多可以取到那些 的区间的右端点的最小值-1 做法：从大到小枚举 ，对于每个 ，统计那些 的区间的右端点的最小值 优化：双指针。从大到小枚举 的时候， 的区间会逐渐变多，所以统计右端点的最小值，实时更新即可。 我们先说明一个细节： 例如：当前区间为 ，那么以 为左端点，不完全包含 的区间有多少个：4 个，分别是 这四个。这个数量刚好对应于 的 数量。 也就是说，如果定好了左边界 ，如果右边完全没有区间，那结果的数量刚好对应于 的数量 依次为基础，我们就可以逐渐的更新出所有的结果了。 时间复杂度为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int MAX_N = 2e5 + 10;struct node { int l, r;} a[MAX_N];int n, m; // n是区间数量，m是范围上限int ans[MAX_N]; // 区间最近右端点long long tot; // 累计最终答案的变量bool cmp(node x, node y) { return x.l &gt; y.l; // 按照左端点降序排序}void solve() { // 输入部分 cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i].l &gt;&gt; a[i].r; // 读入n个区间的左右端点 // 排序 nlogn（这里其实排不排序对结果都没有影响） // sort(a + 1, a + n + 1, cmp); // 将区间按左端点降序排序 // 初始化ans数组 for (int i = 1; i &lt;= m + 1; i++) ans[i] = m + 1; // 初始化为最大可能值m+1(对应右开区间) // 第一次处理：对于每个位置，找到以该位置为左端点的区间中，右端点最小的值。O(n) for (int i = 1; i &lt;= n; i++) ans[a[i].l] = min(ans[a[i].l], a[i].r); // 第二次处理：从右向左维护最小值 O(m) for (int i = m; i &gt;= 1; i--) { ans[i] = min(ans[i], ans[i + 1]); // 确保右边的值不会比当前值小 tot += (ans[i] - i); // 累加每个位置到其对应右端点的距离 } cout &lt;&lt; tot &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Permute K times 2Problem：E - Permute K times 2 （TODO） 题目：给定一个 的排列 执行下面操作 K 次： 将 更新到 输出最后的 排列 约束条件： 思路：这道题太抽象了，我还没理解，暂时先空下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, p[200100]; // n是数组长度，p存储置换数组long long k; // k表示操作次数int cnt[200100], ans[200100]; // ans存储最终答案bool vis[200100]; // 记录某个位置是否被访问过// 快速幂，计算 a^k %m 的值long long fpow(long long a, long long b, long long m) { long long ans = 1; while (b) { if (b &amp; 1) ans = (ans * a) % m; b &gt;&gt;= 1; a = (a * a) % m; } return ans;}void solve() { cin &gt;&gt; n &gt;&gt; k; // 输入n和k for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i]; // 输入置换数组 // 找循环 for (int i = 1; i &lt;= n; i++) { if (!vis[i]) { // 如果当前位置未被访问 vector&lt;int&gt; c; // 用来存储当前循环中的所有数 int j = i; while (!vis[j]) { // 沿着置换一直往下走，直到遇到已访问的数 vis[j] = 1; // 标记已访问 c.push_back(j); // 将当前数加入循环 j = p[j]; // 移动到下一个数 } int len = c.size(); // 循环的长度 int temp = fpow(2, k, len); // 计算2^k mod len // 计算k次操作后每个位置的新位置 for (int j = 0; j &lt; len; j++) { ans[c[j]] = c[(j + temp) % len]; } // cout &lt;&lt; \"第一次循环：\" &lt;&lt; endl; // for (auto x : c) // cout &lt;&lt; x &lt;&lt; \" \"; // cout &lt;&lt; endl; } } for (int i = 1; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; // 输出每个位置在k次操作后的新值}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} F - Avoid Queen AttackProblem：F - Avoid Queen Attack TODO 题目：有一个 N*N 的棋盘。棋盘上放置了 M 个棋子。棋子可以攻击 所在行，列，主次对角线上的任何位置。 请问棋盘上剩余多少位置不会被攻击到？ 示例： 如下图所示的放置条件下，整个棋盘只有 2 个位置是安全的。 约束条件： 思路：TODO G - Edit to MatchProblem：G - Edit to Match Trie 树模板题。TODO 题目：给定 N 个字符串 令 ，进行下面两种操作之一 操作 1：删除 T 最后一个字母，cost 为 1 操作 2：给 T 最后添加一个字母，cost 为 1 求将 T 变为空串或者 中的任何一个串 所付出的最小代价。 约束条件 只包含小写字母 思路：这是一道标准的 Tire 树模板题。 直观思路：先从 的尾部删除若干字符，删除后应该变成某个 的前缀，再开始添加字符。 使用字典树 / Tire 树 即可。 考虑对于 Trie 树上的每个节点，记录其到所有 的节点的最短距离 d。 这个距离等价于：从这个节点代表的字符串开始，至少添加多少个字符能够到达一个 。 查询的时候，从 代表的节点不断向上爬，并统计（向上爬的步数+d）的最小值，就是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Problem: https://atcoder.jp/contests/abc377/tasks/abc377_g// 这是一道标准的 Trie 树模板题#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int MAX_N = 2e5 + 10;int son[MAX_N][26], d[MAX_N], idx;int n;string s[MAX_N];void insert(string s) { int p = 0; // 从根节点开始。根节点的 idx 为 0 // 更新根节点到某个字符串结尾的最短距离 // 注：d 表示当前节点到某个字符串结尾的最短距离 // 注：s.size() 是一个 unsigned 整数，在 min 里使用要 int 强制转换一下 d[p] = min(d[p], (int)s.size()); // 挨个遍历字符串的每个字符 for (int i = 0; i &lt; s.size(); i++) { int u = s[i] - 'a'; if (!son[p][u]) { son[p][u] = ++idx; d[idx] = INT_MAX; } p = son[p][u]; // 更新 d d[p] = min(d[p], (int)s.size() - i - 1); }}int query(string s) { int p = 0; int ans = s.size(); for (int i = 0; i &lt; s.size(); i++) { int u = s[i] - 'a'; if (!son[p][u]) break; p = son[p][u]; // 统计答案 ans = min(ans, (int)s.size() - i - 1 + d[p]); } return ans;}void solve() { cin &gt;&gt; n; d[0] = INT_MAX; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; s[i]; int cur_ans = query(s[i]); insert(s[i]); cout &lt;&lt; cur_ans &lt;&lt; endl; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 376 Summary","slug":"AtCoder_376_Summary","date":"2024-10-23T10:02:55.000Z","updated":"2025-01-04T11:57:52.299Z","comments":true,"path":"2024/blog/33603/","permalink":"http://example.com/2024/blog/33603/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）376 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）376 的总结笔记。 A - Candy ButtonProblem：A - Candy Button 很简单的模拟题。 123456789101112131415161718192021222324252627282930// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_a// 模拟题#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, c;int res;int last;int t;void solve() { cin &gt;&gt; n &gt;&gt; c; last = -c; // 记录上次拿糖的时间，初始值设一个比较小的数即可 for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; t; // 读入当前时间 if (t - last &gt;= c) // 间隔时间超过 c，就可以拿糖 res++, last = t; } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - Hands on Ring (Easy)Problem：B - Hands on Ring (Easy) 根据题目容易看出来，分成 6 种情况来讨论即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_b// 模拟题目#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, Q;int L, R;char op[2];int t;int res;// a 起点，b 障碍，c 终点int move(int a, int b, int c) { if (a &lt; b &amp;&amp; b &lt; c) return a + n - c; if (a &lt; c &amp;&amp; c &lt; b) return c - a; if (b &lt; c &amp;&amp; c &lt; a) return a - c; if (b &lt; a &amp;&amp; a &lt; c) return c - a; if (c &lt; a &amp;&amp; a &lt; b) return a - c; if (c &lt; b &amp;&amp; b &lt; a) return c + n - a; return 0;}void solve() { cin &gt;&gt; n &gt;&gt; Q; L = 1, R = 2; while (Q--) { cin &gt;&gt; op &gt;&gt; t; if (*op == 'L') res += move(L, R, t), L = t; if (*op == 'R') res += move(R, L, t), R = t; } cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Prepare Another BoxProblem：C - Prepare Another Box 贪心 + 二分 题目：有编号为 1~N 的 N 个玩具，有编号为 1 ~ N-1 的 N-1 个盒子。 再买一个大小为 x 的盒子。将 N 个玩具放入这 N 个盒子，并保证任何盒子都大于等于玩具。 求最小的 x 约束条件： 思路：使用二分即可。 时间复杂度 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_c// 贪心题目#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n;int A[N], B[N], c[N];// 检查 x 能否让 B 满足条件// true 表示满足条件，x 偏大，要向左边走// false 表示不满足条件，x 太小，要向右边走bool check(int x) { for (int i = 1; i &lt; n; i++) c[i] = B[i]; c[n] = x; sort(c + 1, c + n + 1); for (int i = 1; i &lt;= n; i++) // 但凡出现了 false，说明插入的 x 太小了 if (A[i] &gt; c[i]) return false; return true;}void solve() { // 读入数据 cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; A[i]; // 读入玩具的大小 for (int i = 1; i &lt;= n - 1; i++) cin &gt;&gt; B[i]; // 读入盒子的大小 // 对 A 升序排序 sort(A + 1, A + n + 1); int l = 1, r = A[n] + 1, ans = -1; while (l &lt; r) { int mid = (r + l) / 2; if (check(mid)) r = mid, ans = mid; else l = mid + 1; } cout &lt;&lt; ans &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - CycleProblem：D - Cycle 题目：N个节点 M 条边的有向简单图。 判断是否有包含 1 节点的环。如果存在，求这个环的最小边数。 约束条件： 思路：本题使用两个方法来解。 方法 1：BFS本题可以使用 BFS 的原因是：边权为 1。如果题目边权不为 1 的话，就没有办法使用 BFS 了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int INF = 1e9 + 10;void solve() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; g(n + 10); // 声明图。+10 是为了留余量 for (int i = 0; i &lt; m; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; g[a].push_back(b); // 添加边 } queue&lt;int&gt; q; vector&lt;int&gt; dis(n + 10, INF); // 先把 1 周围的节点全部放入队列中 for (auto v : g[1]) { q.push(v); dis[v] = 1; } // BFS while (!q.empty()) { int now = q.front(); q.pop(); for (auto next : g[now]) { if (dis[next] &lt; dis[now] + 1) continue; // 更新 next 点的距离 dis[next] = min(dis[next], dis[now] + 1); // 如果遇到了 1，直接退出 if (next == 1) break; // 否则把 next 点加入队列 q.push(next); } } cout &lt;&lt; (dis[1] == INF ? -1 : dis[1]) &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} 方法 2：通用做法“1 节点能回到 1 节点” 意味着：( 1点能走到节点 K ) + ( 反向图 K 能走到 1 节点 ) 这时问题就转化为 求 1-&gt; k 的最短路 + k -&gt; 1 的最短路 相当于两个图的最短路问题，使用两次堆优化版的 Dijkstra 即可。 为了方便，本题使用了结构体，来方便的实现两个图的 dijkstra。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_d#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 2e5 + 10;int n, m, ans;// 声明图的结构体struct Graph { int h[N], e[N], ne[N], idx = 0; int dist[N]; bool st[N]; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 图初始化 Graph() { memset(h, -1, sizeof h); } // 加边 void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; } // dijkstra 求最短路 void dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; heap.push({0, 1}); while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, d = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int next = e[i]; if (dist[next] &gt; d + 1) { dist[next] = d + 1; heap.push({dist[next], next}); } } } }} G1, G2; // 声明了两个图void solve() { // 读入数据 cin &gt;&gt; n &gt;&gt; m; // 建图 for (int i = 1; i &lt;= m; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; G1.add(a, b); // 建正向图 G2.add(b, a); // 建反向图 } G1.dijkstra(); G2.dijkstra(); ans = n + 1; for (int i = 2; i &lt;= n; i++) ans = min(ans, G1.dist[i] + G2.dist[i]); if (ans &gt; n) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Max × SumProblem：E - Max × Sum 贪心 + 大根堆 题目：给定长度为 的序列 和 另 是 的长度为 的子集。求下面表达式的最小值： 有 次询问。 约束条件： 思路：先把表达式拆成两个部分分析一下： 对于一个大小为 的子集 ，前半部分表示子集 中 的最大值，后半部分表示子集内所有元素 的和。 子问题 1：如何枚举所有的可能性？可以按照下图所示，从头遍历每个 。假设当前看到了第 号元素，那么从前面的 中选取 个元素，就能够保证不重不漏的枚举出所有可能的子集 子问题 2：如何维护 的最大值？提前将 A 数组升序排列，这样就能保证，如果当前看到的是编号 的数，无论前面的 如何选 个元素，都能保证 就是能枚举出来的子集的最大值。 子问题 3：如何维护 的最小值？可以使用优先队列 priority_queue（大根堆）来维护。 核心问题转化为如何在 中间选择最小的 个元素。那么只需要每次入栈一个数，再把最大的数字弹出。保证优先队列中只存在 个数即可。 综上所述，算法总时间复杂度为 ，前半部分排序消耗 ，后半部分所有元素一进一出加上大根堆排序消耗 的时间复杂度。总时间复杂度在规定时间范围内。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Problem: https://atcoder.jp/contests/abc376/tasks/abc376_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int MAXN = 2e5 + 10;int T, K, N;PII A[MAXN];priority_queue&lt;int&gt; Q; // 大根堆LL ans, sum;void solve() { cin &gt;&gt; T; while (T--) { cin &gt;&gt; N &gt;&gt; K; for (int i = 1; i &lt;= N; i++) cin &gt;&gt; A[i].first; for (int i = 1; i &lt;= N; i++) cin &gt;&gt; A[i].second; // 排序 sort(A + 1, A + N + 1); // 初始化 ans = 1e18, sum = 0; // 清空堆 （注：priority_queue没有clear函数） while (!Q.empty()) Q.pop(); // 处理前 K-1 个数 for (int i = 1; i &lt; K; i++) { Q.push(A[i].second); sum += (LL)A[i].second; } // 从第 K 个数开始 for (int i = K; i &lt;= N; i++) { sum += (LL)A[i].second; ans = min(ans, (LL)A[i].first * sum); Q.push(A[i].second); // 把看过的 B 的最大值弹出来去掉，就能保证 sum 的值是最小的 sum -= (LL)Q.top(); Q.pop(); } cout &lt;&lt; ans &lt;&lt; endl; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"AtCoder Beginner Contest 363 Summary","slug":"AtCoder_363_Summary","date":"2024-07-22T06:41:52.000Z","updated":"2025-01-04T11:57:52.293Z","comments":true,"path":"2024/blog/5677/","permalink":"http://example.com/2024/blog/5677/","excerpt":"本文是 AtCoder Beginner Conteset（ABC）363 的总结笔记。","text":"本文是 AtCoder Beginner Conteset（ABC）363 的总结笔记。 A - Piling UpProblem：A - Piling Up 省略 123456789101112131415161718192021222324// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_a#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;void solve() { int n; cin &gt;&gt; n; if (n &gt;= 200) cout &lt;&lt; 300 - n &lt;&lt; endl; else if (n &gt;= 100) cout &lt;&lt; 200 - n &lt;&lt; endl; else cout &lt;&lt; 100 - n &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} B - Japanese Cursed DollProblem：B - Japanese Cursed Doll 省略。 12345678910111213141516171819202122232425262728293031323334353637// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_b#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 110;int cnt[N];int n, t, p;void solve() { cin &gt;&gt; n &gt;&gt; t &gt;&gt; p; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; cnt[x]++; } for (int i = 1; i &lt; N; i++) cnt[i] += cnt[i - 1]; // 遍历长度 for (int len = 100; len &gt;= 0; len--) // 长度为 i 以上的人数达到了 p 人 if (cnt[100] - cnt[len - 1] &gt;= p) { cout &lt;&lt; max(0, t - len) &lt;&lt; endl; break; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} C - Avoid K Palindrome 2Problem：C - Avoid K Palindrome 2 模拟题。 题目：给定长度为 的小写字母字符串 。求 的排列数量，且其中不含长度为 的回文串子串。 约束条件： 思路：按照题目要求进行模拟即可。 关键技术有两个： 如何求 的全排列：使用 STL 的全排列函数 next_permutation 即可。并且 next_permutation 会自动去重。时间复杂度 。（注意，next_permutation 使用前要 sort，否则枚举会遗漏） 如何快速验证回文串：双指针左右向中间夹逼即可。时间复杂度 整体时间复杂度最极端情况下是 ，在本题的规模下大约是 1e8，在约束时间范围内。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_c#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, k;string s;// 快速判断回文bool check(int l, int r) { while (l &lt; r) if (s[l++] != s[r--]) return 0; return 1;}void solve() { cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; s; sort(s.begin(), s.end()); int res = 0; int len = s.size(); do { bool can = true; for (int i = 0; i + k - 1 &lt; len; i++) { if (check(i, i + k - 1)) { can = false; break; } } if (can) res++; } while (next_permutation(s.begin(), s.end())); // 备注：next_permutation 在用的时候会自动去重 cout &lt;&lt; res &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} D - Palindromic NumberProblem：D - Palindromic Number 题目：形如 或者 的数称为回文数。求第 大的回文数。 约束条件： 思路：当对比数字大小的时候，有如下规律： 位数长的一定比位数短的数字大 相同长度下，高位数大的数字大 对于一个回文串数，后半部分是前半部分的镜像，所以我们可以暂时忽略后半部分，仅仅使用上面两条规则，就可以比较出回文串数字的大小。 通过观察，实际可以发现有如下的关系。此时回文串数字的大小也是递增的。 根据上面规则，想要求出第 大的数： 先通过迭代，确定这个数的位数范围，求出前面位数累计下来的回文串数 ； 然后直接根据 确定在当前位数下的偏移量，再回文镜像生成需要的数字即可。 这个数字会非常的大，但是能够看出来，回文串的前半部分肯定能被 long long 存下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_d// 找第n大的回文数#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;LL N;// 快速幂模板LL qpow(LL a, LL b) { LL res = 1; while (b) { if (b &amp; 1) res *= a; a *= a; b &gt;&gt;= 1; } return res;}void solve() { cin &gt;&gt; N; // 特判 if (N == 1) { cout &lt;&lt; 0 &lt;&lt; endl; return; } // 偏移量修正（把0给修正掉） N--; // 枚举回文串数字的位数 for (int d = 1;; d++) { // 回文串数字对称轴左侧的位数 int x = (d + 1) / 2; if (N &lt;= 9 * qpow(10, x - 1)) { string S = to_string(qpow(10, x - 1) + N - 1); // 把S长度扩展为d，后面不足的位置用' '补充 S.resize(d, ' '); // 把后面的空位补上 for (int i = x; i &lt; d; i++) S[i] = S[d - 1 - i]; cout &lt;&lt; S &lt;&lt; endl; return; } else { N -= 9 * qpow(10, x - 1); } }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} E - Sinking LandProblem：E - Sinking Land 优先队列 BFS 题目：给定一个 的网格，每个格点有高度值 。网格外侧被海洋环绕，海平面以每单位 1 的速度上升。 输出 时刻，没有被水淹没的格点的数量。 约束条件： 思路：经典的优先队列 BFS 模型。 如下图所示。由于水肯定是从外边界往中心走。在初始化的时候，将所有外边界的点（粉色区域）都存入优先队列中。这里使用小根堆模型。 取出最小值，可知当海平面高度为 2 的时候，会从这里开始灌水。此时将 2 周围的点存入优先队列，挨个弹出，直到优先队列最小值大于 2. 再取出优先队列的最小值 3，说明海平面高度为 3 的时候，会开始灌水…….依次循环。 所有的点都会进出一次优先队列，总时间复杂度为 。（备注： 是小根堆提供的时间复杂度） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_e#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};struct Node { int x, y, t; bool operator&lt;(const Node&amp; a) const { return t &gt; a.t; }};priority_queue&lt;Node&gt; Q;const int N = 1010;int H, W, Y;int A[N][N];bool st[N][N];int res[100010];void solve() { // 读入数据 cin &gt;&gt; H &gt;&gt; W &gt;&gt; Y; for (int i = 1; i &lt;= H; i++) for (int j = 1; j &lt;= W; j++) cin &gt;&gt; A[i][j]; // 把边缘的格子加入小根堆 for (int i = 1; i &lt;= H; i++) for (int j = 1; j &lt;= W; j++) if (i == 1 || j == 1 || i == H || j == W) { st[i][j] = true; Q.push((Node){i, j, A[i][j]}); } int T = 0; while (Q.size()) { // 拿出当前最低的格子 Node now = Q.top(); Q.pop(); int x = now.x, y = now.y, t = now.t; T = max(T, t); res[T]++; // T 高度被淹的格子数量+1 // 看一下这个格子周围的四个方向 for (int i = 0; i &lt; 4; i++) { int a = x + dx[i], b = y + dy[i]; // 越界 if (a &lt; 1 || a &gt; H || b &lt; 1 || b &gt; W) continue; // 已经在队列中 if (st[a][b]) continue; // 入队 Q.push((Node){a, b, A[a][b]}); st[a][b] = true; } } // 计算前缀和（已知i时刻淹了的格子数量，就知道0~i时刻总共被淹的格子数量） for (int i = 1; i &lt;= Y; i++) res[i] += res[i - 1]; // 输出结果 for (int i = 1; i &lt;= Y; i++) cout &lt;&lt; H * W - res[i] &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} F - Palindromic ExpressionProblem：F - Palindromic Expression DFS 题目：给定一个整数 ，输出一个满足下面条件的表达式 ： 长度在 以内，只包含数字 和 乘号 * 是回文串，且第一个字符是数字 表达式 的计算结果等于 例如：363 可以拆成 11*3*11 或者直接输出 363 约束条件： 思路：使用 DFS 搜索。 对于一个数字 n，我们可以先判断能否拆成 的形式，并且 x 和 y 轴对称。然后再将 作为输入，再向下继续 DFS，直到把它拆成一个形如 121 样子的回文串数字。最后拼接即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Problem: https://atcoder.jp/contests/abc363/tasks/abc363_f// DFS#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;LL N;string dfs(LL n) { string s = to_string(n); string s_rev = s; reverse(s_rev.begin(), s_rev.end()); int len = s.size(); bool zero_flag = false; // 遍历看中间有没有 0 出现（因为我们想要的数中不能有0） for (int i = 0; i &lt; len; i++) if (s[i] == '0') zero_flag = true; // 如果没有 0 出现，并且是回文，直接返回 if (!zero_flag &amp;&amp; s == s_rev) return s; for (int i = 2, l = sqrt(n); i &lt;= l; i++) { if (n % i == 0) { bool flag = true; int t = i, j = 0; // 看看t里面是否有0（因为我们想要的数中不能有0） while (t) { if (t % 10 == 0) flag = false; t /= 10; } t = i; // 中间出现 0 了，直接跳过 if (!flag) continue; // 算出计算和 i 对称的数 j while (t) j = j * 10 + t % 10, t /= 10; // 如果找到了这一对对称的数，就继续往下面搜 if ((n / i) % j == 0) { string ret = dfs(n / i / j); // 如果得到的结果不是空串 if (ret != \"\") return to_string(i) + \"*\" + ret + \"*\" + to_string(j); } } } return \"\";}void solve() { cin &gt;&gt; N; string ret = dfs(N); if (ret != \"\") cout &lt;&lt; ret &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl;}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"}]},{"title":"质数的基础知识","slug":"质数的基础知识","date":"2023-10-01T07:02:12.000Z","updated":"2025-01-04T11:57:52.301Z","comments":true,"path":"2023/blog/59545/","permalink":"http://example.com/2023/blog/59545/","excerpt":"","text":"在大于 1 的整数中，如果只能被 1 和本身整除，就被称为质数，或素数。 1. 质数的判定——试除法方法 1是最笨的方法，复杂度为 。因为没有经过优化，不建议使用。 123456789bool is_prime(int n){ // 如果 n &lt; 2 则肯定不为质数 if( n &lt; 2 ) return false; for(int i = 2 ; i &lt; n ; i++){ // 任何一个数 i 能整除 n，说明 n 不是质数 if( n % i == 0) return false; } return true;} 方法 2：优化后性质：如果 能整除 ， 那么 也能整除 。（即 的约数都是成对出现的，例如，2 能整除 12，6 也能整除 12 ）。 所以我们可以只枚举一对中较小的那一个。那么只需要枚举验证 ， 之间的数即可。复杂度为 。 AcWing 866: 试除法判定质数问题链接：https://www.acwing.com/problem/content/868/ 题目： 给定 n 个正整数 ，判定每个数是否是质数。 数据范围： 解题思路： 123456789101112131415161718192021222324252627282930313233343536// Problem: https://www.acwing.com/problem/content/868/// 质数判定#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;int n, x;bool is_prime(int n) { if (n &lt; 2) return false; for (int i = 2; i &lt;= n / i; i++) { if (n % i == 0) return false; } return true;}void solve() { cin &gt;&gt; n; while (n--) { cin &gt;&gt; x; if (is_prime(x)) cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl; }}int main() { cin.tie(0); ios_base::sync_with_stdio(false); solve(); return 0;} 注意：判断条件处最佳写法为： i &lt;= n / i 。 不推荐写成 i &lt;= sqrt(n) 因为每次都会计算一次 sqrt，非常的慢，影响执行速度； 不推荐写成 i * i &lt;= n 因为当 i 非常大，逼近 int 的上限 2147483647 时，容易导致 i*i 的结果溢出变为一个负数，此时的程序时不稳定的。 2. 分解质因数——试除法质因数：是指能够整除给定正整数的质数。 1 没有质因子。 5 只有 1 个质因子，5 本身。（5 是质数） 6 的质因子是 2 和 3。(6 = 2 × 3) 2、4、8、16 等只有 1 个质因子：2。（2 是质数，4 =2²，8 = 2³，如此类推） 10 有 2 个质因子：2 和 5。(10 = 2 × 5) 从小到大尝试 n 的所有的因数。 只需要枚举到 sqrt(n) 即可（因为 n 中最多只包含一个大于 n 的质因数） 时间复杂度最慢是 AcWing 867: 分解质因数问题链接：https://www.acwing.com/problem/content/869/ 题目： 给定个正整数 ，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。 数据范围： 解题思路： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void divide(int x){ for (int i = 2; i &lt;= x / i; i ++ ) if (x % i == 0) { int s = 0; while (x % i == 0) x /= i, s ++ ; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl; } if (x &gt; 1) cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; cout &lt;&lt; endl;}int main(){ int count; cin &gt;&gt; count; while(count--){ int n; cin &gt;&gt; n; divide(n); } return 0;} 3. 质数筛选参考：质数其实没有那么多。100 万以内，大概有 8 万个质数。 方法 1：这种筛选方法的时间复杂度为： 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;int primes[N] , cnt ;bool st[N];void get_primes(int n){ for(int i = 2 ; i &lt;= n ; i++ ){ // 如果这个数已经被筛过了，那么留下的数是一个质数，直接就存到 primes 数组中 if(!st[i]){ // 把这个质数存进 primes 数组中 primes[ cnt ++ ] = i ; } // j 从 2i 开始循环，查看i的倍数，给它赋值为true，标记他不是一个质数 for(int j = i + i ; j &lt;= n ; j += i) st[j] = true; }}int main(){ int n; cin &gt;&gt; n ; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; return 0;} 方法 2：埃氏筛法质数定理：1 ～ n 中，有 个质数。 这个方法中的时间复杂度约为 ，基本上和 O(n) 复杂度是一个级别的。 这个算法也称为 埃氏筛法。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;int primes[N] , cnt ;bool st[N];void get_primes(int n){ for(int i = 2 ; i &lt;= n ; i++ ){ // 确认了这个数是一个质数了 if(!st[i]){ // 把这个质数存进 primes 数组中 primes[cnt++] = i; // 只需要把质数的倍数筛掉，就可以了 for(int j = i+i ; j &lt;= n ; j += i) st[j] = true; } }}int main(){ int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; return 0;} 方法 3：线性筛法n 只会被最小质因子筛掉 每一个数只会被最小质因子筛一次，所以是线性的。 注：下面两个代码的 primes 数组声明方式不一样。一个用普通数组，一个用 vector。供参考 12345678910111213141516171819202122232425262728293031// 注释版本#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000010;int primes[N] , cnt ;bool st[N];void get_primes(int n){ for(int i = 2 ; i &lt;= n ; i++ ){ // 如果这个数没被筛掉，那么这个数为质数 if(!st[i]) primes[cnt ++] = i; // 从小到大枚举所有的质数 for(int j = 0 ; primes[j] &lt;= n / i ; j ++){ // 把当前质数和i的乘积筛掉 st[ primes[j] * i] = true; // 只用最小质因子来筛选 if( i % primes[j] == 0) break; // 当这句话发生的时候，说明primes[j]一定是i的最小质因子 // 1. i % primes[j] == 0，此时，primes[j]一定是i的最小质因子，即 primes[j] 一定是 primes[j] * i 的最小质因子 // 2. i % primes[j] != 0，primes[j] 一定小于i的所有质因子，即 primes[j] 一定是 primes[j] * i 的最小质因子 } }}int main(){ int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; cnt &lt;&lt; endl; return 0;} 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N = 1000010;int cnt;bool st[N];vector&lt;int&gt; primes;void get_primes(int n) { for (int i = 2; i &lt;= n; i++) { if (!st[i]) primes.push_back(i); for (int j = 0; primes[j] &lt;= n / i; j++) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } }}int main() { int n; cin &gt;&gt; n; get_primes(n); cout &lt;&lt; primes.size() &lt;&lt; endl;}","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]}],"categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://example.com/tags/Algorithm/"},{"name":"Prgoramming Contest","slug":"Prgoramming-Contest","permalink":"http://example.com/tags/Prgoramming-Contest/"},{"name":"AtCoder","slug":"AtCoder","permalink":"http://example.com/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"http://example.com/tags/ABC/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"Math","slug":"Math","permalink":"http://example.com/tags/Math/"}]}